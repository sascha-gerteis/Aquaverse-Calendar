<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Columbia Pictures Aquaverse - 2025 Content Calendar</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>

  <style>
    :root {
      --primary: #1a2a6c; --secondary: #b21f1f; --accent: #fdbb2d;
      --light: #f5f7fa; --dark: #333; --gray: #6c757d;
    }
    * { margin:0; padding:0; box-sizing:border-box; font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
    body { background:var(--light); color:var(--dark); line-height:1.6; padding:20px; user-select:none; }
    .container { max-width:1400px; margin:0 auto; }

    header {
      display:flex; align-items:center; justify-content:space-between; gap:16px;
      margin-bottom:30px; padding:20px;
      background:linear-gradient(135deg, var(--primary), var(--secondary), var(--accent));
      color:white; border-radius:10px; box-shadow:0 4px 12px rgba(0,0,0,0.1);
    }
    .brand { display:flex; flex-direction:column; }
    h1 { font-size:2rem; margin-bottom:6px; }
    .subtitle { font-size:1rem; opacity:.9; }

    .header-actions { display:flex; gap:10px; }
    .link-btn {
      display:inline-flex; align-items:center; gap:8px; text-decoration:none;
      background:rgba(255,255,255,.15); color:white; padding:10px 14px; border-radius:8px; font-weight:700; transition:.2s ease;
    }
    .link-btn:hover { background:rgba(255,255,255,.25); transform:translateY(-1px); }

    .controls {
      display:flex; justify-content:space-between; align-items:center;
      margin:20px 0; padding:15px; background:white; border-radius:10px;
      box-shadow:0 2px 8px rgba(0,0,0,0.1); flex-wrap:wrap; gap:15px;
    }
    .month-navigation { display:flex; align-items:center; gap:15px; }
    .nav-btn {
      background:var(--primary); color:white; border:none; padding:10px 15px; border-radius:50px;
      cursor:pointer; display:flex; align-items:center; gap:8px; font-weight:600; transition:all .3s ease;
      box-shadow:0 2px 5px rgba(0,0,0,0.2);
    }
    .nav-btn:hover { background:#2a3a8c; transform:translateY(-2px); }
    .month-year { font-size:1.5rem; font-weight:700; color:var(--primary); min-width:180px; text-align:center; }

    .view-controls { display:flex; gap:10px; align-items:center; }
    .view-btn {
      padding:8px 15px; border:2px solid var(--primary); background:white; color:var(--primary);
      border-radius:5px; cursor:pointer; font-weight:600; transition:all .3s ease;
    }
    .view-btn.active { background:var(--primary); color:white; }

    .market-selector { display:flex; gap:5px; flex-wrap:wrap; }
    .market-btn {
      padding:5px 10px; border:1px solid var(--primary); background:white; color:var(--primary);
      border-radius:20px; cursor:pointer; font-size:.8rem; transition:all .3s ease;
    }
    .market-btn.active { background:var(--primary); color:white; }

    .edit-controls { display:flex; gap:10px; }
    .edit-btn {
      padding:8px 15px; border:2px solid var(--accent); background:white; color:var(--accent);
      border-radius:5px; cursor:pointer; font-weight:600; transition:all .2s ease;
    }
    .edit-btn.active { background:var(--accent); color:white; }

    .dashboard { display:grid; grid-template-columns:1fr 1fr; gap:20px; margin-bottom:30px; }
    .folder-status, .content-summary { background:white; padding:20px; border-radius:10px; box-shadow:0 2px 8px rgba(0,0,0,0.1); }
    .folder-status h2, .content-summary h2 { color:var(--primary); margin-bottom:15px; padding-bottom:10px; border-bottom:2px solid #f0f0f0; }
    .folder-item { display:flex; justify-content:space-between; margin-bottom:10px; padding:8px 0; }
    .folder-name { font-weight:600; }
    .folder-count { background:#e9ecef; padding:2px 10px; border-radius:20px; font-weight:600; }

    .content-stats { display:grid; grid-template-columns:1fr 1fr; gap:15px; }
    .stat-item { text-align:center; padding:15px; border-radius:8px; background:#f8f9fa; }
    .stat-number { font-size:1.8rem; font-weight:700; color:var(--primary); }
    .stat-label { font-size:.9rem; color:var(--gray); }

    .calendar-container {
      background:white; border-radius:10px; overflow:hidden; box-shadow:0 2px 8px rgba(0,0,0,0.1); margin-bottom:30px;
      overflow-x:auto;
    }
    .calendar-inner { min-width: 900px; }

    .calendar-header {
      display:grid; grid-template-columns:repeat(7, 1fr);
      background:var(--primary); color:white; text-align:center; font-weight:600;
    }
    .calendar-header div { padding:15px 5px; }
    .calendar-week { display:grid; grid-template-columns:repeat(7, 1fr); border-bottom:1px solid #e9ecef; }

    .calendar-day {
      min-height:140px; padding:10px; border-right:1px solid #e9ecef; position:relative;
      transition:all .2s ease; cursor:pointer; word-break:break-word;
    }
    .calendar-day:hover { background:#f8f9fa; }
    .calendar-day.editable:hover { background:#fff9e6; }
    .calendar-day:last-child { border-right:none; }

    .date-number { font-weight:700; margin-bottom:5px; color:#495057; display:flex; justify-content:space-between; align-items:center; gap:8px; }
    .edit-indicator { color:var(--accent); font-size:.8rem; }

    .content-type { font-size:.85rem; padding:4px 8px; border-radius:4px; margin-bottom:5px; color:white; font-weight:600; display:inline-block; }
    .shortform { background:#28a745; }
    .ai-shortform { background:#007bff; }
    .ai-carousel { background:#17a2b8; }
    .real-carousel { background:#fd7e14; }
    .longform { background:#6f42c1; }
    .no-post { background:#6c757d; }

    .market-tags { display:flex; flex-wrap:wrap; gap:4px; margin-top:5px; }
    .market-tag { font-size:.65rem; padding:2px 6px; border-radius:3px; background:#e9ecef; }
    .content-theme { font-size:.8rem; color:#495057; margin-top:6px; font-style:italic; overflow:hidden; display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; }

    .activity-block {
      background: #fdfdfd;
      border: 1px solid #e9ecef;
      border-radius: 6px;
      padding: 8px;
      margin-top: 8px;
      cursor: pointer;
      transition: all .2s ease;
    }
    .editable .activity-block:hover {
      background: #fff;
      border-color: var(--primary);
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }

    
    .preview-block { margin-bottom: 24px; }
    .media-preview { margin-top: 10px; margin-bottom: 14px; }
    .media-frame {
      width: 100%;
      border-radius: 10px;
      overflow: hidden;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .media-frame.media-vertical { aspect-ratio: 9 / 16; }
    .media-frame.media-square  { aspect-ratio: 1 / 1; }
    .media-frame.media-landscape { aspect-ratio: 16 / 9; }
    .media-frame img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }
    .media-label {
      margin-top: 8px;
      font-size: 0.85rem;
      color: var(--gray);
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .media-label i { font-size: 0.9rem; }

    .preview-meta-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 10px;
      font-size: 0.85rem;
    }
    .preview-meta-pill {
      background: #f1f3f5;
      border-radius: 999px;
      padding: 4px 10px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .preview-meta-pill i { font-size: 0.9rem; }

    .preview-title-activity {
      color: var(--primary);
      margin-bottom: 6px;
      font-size: 1.05rem;
      font-weight: 700;
    }
    .preview-theme {
      font-size: 0.95rem;
      color: var(--dark);
      font-style: italic;
      white-space: pre-wrap;
      margin-top: 4px;
    }

    .mobile-list .edit-indicator { float: right; }
    .editable .calendar-day:hover .edit-indicator { opacity: 1; }

    .platform-selector { display: flex; gap: 20px; margin-top: 10px; }
    .platform-selector input[type="checkbox"] { margin-right: 5px; }
    .platform-selector label { font-weight: normal; display: flex; align-items: center; gap: 6px; cursor: pointer; }
    .platform-selector .fa-brands { font-size: 1.2rem; }
    .fa-facebook { color: #1877F2; }
    .fa-instagram { color: #E4405F; }
    .fa-youtube { color: #FF0000; }
    .fa-google { color: #4285F4; }

    .legend { display:flex; justify-content:center; flex-wrap:wrap; gap:15px; margin-top:20px; }
    .legend-item { display:flex; align-items:center; gap:5px; }
    .legend-color { width:20px; height:20px; border-radius:4px; }

    .empty-day { background:#f8f9fa; padding:6px; border-radius:6px; display:inline-block; }

    .other-month { background:#f0f2f5; color:#adb5bd; }
    .swipe-info { text-align:center; margin-top:15px; color:var(--gray); font-size:.9rem; }

    .modal { display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:1000; justify-content:center; align-items:center; padding:16px; }
    .modal-content { background:white; padding:22px; border-radius:10px; width:92%; max-width:640px; box-shadow:0 5px 15px rgba(0,0,0,0.3); max-height:90vh; overflow-y:auto; }
    .modal-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:14px; padding-bottom:10px; border-bottom:1px solid #e9ecef; }
    .modal-title { font-size:1.3rem; color:var(--primary); }
    .close-modal { background:none; border:none; font-size:1.5rem; cursor:pointer; color:var(--gray); }

    .form-group { margin-bottom:12px; }
    .form-group label { display:block; margin-bottom:6px; font-weight:600; color:var(--dark); }
    .form-control { width:100%; padding:10px; border:1px solid #ced4da; border-radius:6px; font-size:1rem; }
    textarea.form-control { min-height:100px; resize:vertical; }
    .form-actions { display:flex; justify-content:flex-end; gap:10px; margin-top:16px; }
    .btn { padding:10px 16px; border:none; border-radius:6px; cursor:pointer; font-weight:600; transition:all .2s ease; }
    .btn-primary { background:var(--primary); color:white; }
    .btn-secondary { background:var(--gray); color:white; }
    .btn-danger { background:var(--secondary); color:white; }

    .market-checkboxes { display:grid; grid-template-columns:repeat(3, 1fr); gap:10px; margin-top:10px; }
    .market-checkbox { display:flex; align-items:center; gap:5px; }

    #select-all-markets {
      transition: opacity 0.2s ease;
    }
    #select-all-markets:hover {
      opacity: 0.7;
    }

    #video-player-preview {
      transition: opacity 0.3s ease;
    }
    
    #video-player-preview[poster] {
      background: #000;
    }

    .save-notification {
      position:fixed; bottom:20px; right:20px; background:var(--primary); color:white;
      padding:10px 20px; border-radius:5px; box-shadow:0 2px 10px rgba(0,0,0,0.2);
      display:none; z-index:1001;
    }

    
    .carousel-video-section {
      margin-top: 15px;
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      border: 1px dashed #ccc;
    }
    
    .carousel-video-preview {
      margin-top: 10px;
    }
    
    .carousel-video-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 8px;
      background: white;
      border-radius: 6px;
      margin-bottom: 8px;
    }
    
    .carousel-video-item video {
      width: 80px;
      height: 80px;
      object-fit: cover;
      border-radius: 4px;
    }
    
    .carousel-video-info {
      flex: 1;
    }
    
    .carousel-video-actions {
      display: flex;
      gap: 5px;
    }

    
    .carousel-images-preview {
      margin-top: 10px;
    }
    
    .carousel-images-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
      margin-top: 10px;
    }
    
    .carousel-image-item {
      position: relative;
      aspect-ratio: 1 / 1;
      border-radius: 6px;
      overflow: hidden;
    }
    
    .carousel-image-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    
    .generate-video-btn {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(26, 42, 108, 0.9);
      color: white;
      border: none;
      padding: 8px;
      font-size: 0.75rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 5px;
      opacity: 0;
      transform: translateY(100%);
    }
    
    .carousel-image-item:hover .generate-video-btn {
      opacity: 1;
      transform: translateY(0);
    }
    
    .generate-video-btn:hover {
      background: rgba(26, 42, 108, 1);
    }
    
    .generate-video-btn.loading {
      background: rgba(253, 187, 45, 0.9);
    }
    
    .generate-video-btn.loading i {
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    
    .video-generation-status {
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 6px;
      border-left: 4px solid var(--accent);
      display: none;
    }
    
    .video-generation-status.active {
      display: block;
    }
    
    .video-generation-status .status-text {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    
    #video-translation-upload-box:hover {
      background: #eef0ff;
      border-color: #764ba2;
    }

    .translation-lang-option:hover {
      background: #e9ecef;
    }

    .translation-lang-option input:checked {
      accent-color: var(--primary);
    }

    .translation-progress-item {
      background: #f8f9ff;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 12px;
      border-left: 4px solid #667eea;
    }

    .translation-progress-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .translation-progress-lang {
      font-weight: 600;
      font-size: 1.05rem;
      color: #333;
    }

    .translation-status-badge {
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 0.85rem;
      font-weight: 600;
    }

    .translation-status-processing {
      background: #fff3cd;
      color: #856404;
    }

    .translation-status-success {
      background: #d4edda;
      color: #155724;
    }

    .translation-status-error {
      background: #f8d7da;
      color: #721c24;
    }

    .translation-progress-bar {
      height: 6px;
      background: #e0e0e0;
      border-radius: 10px;
      overflow: hidden;
    }

    .translation-progress-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      transition: width 0.3s ease;
      animation: progress-pulse 1.5s ease-in-out infinite;
    }

    @keyframes progress-pulse {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; }
    }

    .translation-result-card {
      background: white;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 3px 10px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
    }

    .translation-result-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 5px 20px rgba(0,0,0,0.15);
    }

    .translation-result-header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 12px 15px;
      font-weight: 600;
      font-size: 1.1rem;
    }

    .translation-result-body {
      padding: 15px;
    }

    .translation-result-video {
      width: 100%;
      border-radius: 8px;
      margin-bottom: 12px;
      background: #000;
    }

    .translation-result-actions {
      display: flex;
      gap: 8px;
    }

    .translation-result-btn {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .translation-regenerate-btn {
      background: #f8f9ff;
      color: #667eea;
      border: 2px solid #667eea;
    }

    .translation-regenerate-btn:hover {
      background: #667eea;
      color: white;
    }

    .translation-download-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .translation-download-btn:hover {
      opacity: 0.9;
    }

    .translation-delete-btn {
      background: #dc3545 !important;
      color: white;
    }

    .translation-delete-btn:hover {
      background: #c82333 !important;
      transform: scale(1.05);
    }

    .translation-result-card {
      transition: all 0.3s ease;
    }

    
    @media (max-width:768px) {
      header { flex-direction:column; align-items:flex-start; }
      .dashboard { grid-template-columns:1fr; }
      .calendar-inner { min-width: 720px; }
      .calendar-header div { padding:10px 4px; font-size:.85rem; }
      .calendar-day { min-height:110px; padding:6px; }
      .content-type { font-size:.75rem; padding:3px 6px; }
      .content-theme { -webkit-line-clamp: 3; font-size:.75rem; }
      .month-year { font-size:1.25rem; }
      .controls { flex-direction:column; align-items:flex-start; }
      .market-checkboxes { grid-template-columns:repeat(2, 1fr); }
      .modal-content { width: 100%; padding:18px; }
      .carousel-images-grid { grid-template-columns: repeat(2, 1fr); }
      
      .generate-video-btn {
        opacity: 1;
        transform: translateY(0);
        font-size: 0.7rem;
        padding: 6px;
      }
      

    }

    .calendar-fade { animation:fadeIn .5s ease-in-out; }
    @keyframes fadeIn { from { opacity:.5; } to { opacity:1; } }

    .global-view .market-tags { display:none; }
    .individual-view .market-tags { display:flex; }

    
    .post-status {
      display: inline-block;
      background: #28a745;
      color: white;
      font-size: 0.65rem;
      padding: 2px 6px;
      border-radius: 10px;
      font-weight: 600;
      margin-left: 8px;
      vertical-align: middle;
      box-shadow: 0 1px 3px rgba(0,0,0,0.3);
    }
    .post-status.not-posted {
      background: #dc3545;
    }
    .post-status.partial-posted {
      background: #ffc107;
      color: #333;
    }

    .activity-block {
      position: relative;
    }

    
    @media (max-width:600px){
      .calendar-header { display: none !important; }
      .calendar-inner { min-width: 0; }
      .calendar-week { display: none !important; }

      #calendar .mobile-list { display:flex; flex-direction:column; }

      #calendar .mobile-list .calendar-day {
        display:block;
        min-height:unset;
        padding:12px;
        margin:10px 12px;
        border:1px solid #e9ecef;
        border-radius:10px;
        box-shadow:0 1px 3px rgba(0,0,0,0.04);
      }

      .calendar-day.other-month{ display:none !important; }

      .month-navigation {
        gap: 4px;
        width: 100%;
        justify-content: space-between;
      }

      .month-year {
        min-width: unset;
        font-size: 0.9rem;
        flex: 1;
        text-align: center;
      }

      .nav-btn {
        flex-shrink: 0;
        padding: 6px 8px;
        font-size: 0.8rem;
        border-radius: 5px;
      }

      .controls {
        padding: 8px;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <header>
    <div class="brand">
      <h1>Columbia Pictures Aquaverse</h1>
      <p class="subtitle">2025 Global Content Calendar</p>
    </div>
    <div class="header-actions">
      <a class="link-btn" id="beachclub-link" href="#quuba" title="Open the Beach Club page">
        <i class="fa-solid fa-umbrella-beach"></i> Beach Club Page
      </a>
    </div>
  </header>

  <div id="calendar-view" style="display:block;">
    <div class="controls">
      <div class="month-navigation">
        <button class="nav-btn" id="prev-month"><i class="fas fa-chevron-left"></i> Previous</button>
        <div class="month-year" id="current-month">November 2025</div>
        <button class="nav-btn" id="next-month">Next <i class="fas fa-chevron-right"></i></button>
      </div>

      <div class="view-controls">
        <button class="view-btn active" id="global-view">Global View</button>
        <button class="view-btn" id="individual-view">Individual View</button>
        <div class="market-selector" id="market-selector" style="display:none;"></div>
      </div>

      <div class="edit-controls">
        <button class="edit-btn" id="edit-mode">Edit Mode</button>
        <button class="edit-btn" id="logout-btn" style="display:none;">Sign out</button>
      </div>
    </div>

    <div class="dashboard">
      <div class="folder-status">
        <h2 style="padding-top: 5px;">Video Inventory</h2>

        <div class="folder-item">
          <span class="folder-name">Available AI Shortform Videos</span>
          <span class="folder-count" id="available-video-count" style="background:var(--primary); color:white;">...</span>
        </div>

        <div class="folder-item">
          <span class="folder-name">Scheduled Shortform (all markets)</span>
          <span class="folder-count" id="scheduled-shortform-total">0 posts</span>
        </div>

        <div class="folder-item">
          <span class="folder-name">US Shortform</span>
          <span class="folder-count" id="shortform-us-count">0</span>
        </div>
        <div class="folder-item">
          <span class="folder-name">Korea Shortform</span>
          <span class="folder-count" id="shortform-korea-count">0</span>
        </div>
        <div class="folder-item">
          <span class="folder-name">India Shortform</span>
          <span class="folder-count" id="shortform-india-count">0</span>
        </div>
        <div class="folder-item">
          <span class="folder-name">France Shortform</span>
          <span class="folder-count" id="shortform-france-count">0</span>
        </div>
        <div class="folder-item">
          <span class="folder-name">Japan Shortform</span>
          <span class="folder-count" id="shortform-japan-count">0</span>
        </div>
        <div class="folder-item">
          <span class="folder-name">UK Shortform</span>
          <span class="folder-count" id="shortform-uk-count">0</span>
        </div>
        <div class="folder-item">
          <span class="folder-name">Germany Shortform</span>
          <span class="folder-count" id="shortform-germany-count">0</span>
        </div>
        <div class="folder-item">
          <span class="folder-name">Thailand Shortform</span>
          <span class="folder-count" id="shortform-thailand-count">0</span>
        </div>

        <h2>Canto Folder Status</h2>
        <div class="folder-item">
          <span class="folder-name">Carousels_Ready</span>
          <span class="folder-count" id="ready-count">112 items</span>
        </div>
        <div class="folder-item">
          <span class="folder-name">Carousels_Posted</span>
          <span class="folder-count" id="posted-count">0 items</span>
        </div>
        <p style="margin-top:15px; font-size:.9rem; color:var(--gray);">
          All markets follow the same posting schedule with localized content.
        </p>
      </div>

      <div class="content-summary">
        <h2>Monthly Content Summary</h2>
        <div class="content-stats">
          <div class="stat-item"><div class="stat-number" id="total-posts">0</div><div class="stat-label">Total Posts</div></div>
          <div class="stat-item"><div class="stat-number" id="shortform-count">0</div><div class="stat-label">Shortform</div></div>
          <div class="stat-item"><div class="stat-number" id="ai-shortform-count">0</div><div class="stat-label">AI Shortform</div></div>
          <div class="stat-item"><div class="stat-number" id="ai-count">0</div><div class="stat-label">AI Carousels</div></div>
          <div class="stat-item"><div class="stat-number" id="real-count">0</div><div class="stat-label">Real Carousels</div></div>
          <div class="stat-item"><div class="stat-number" id="longform-count">0</div><div class="stat-label">Longform</div></div>
        </div>
      </div>
    </div>

    <div class="calendar-container" id="calendar-container">
      <div class="calendar-inner" id="calendar"></div>
    </div>

    <div class="swipe-info">
      <i class="fas fa-arrows-left-right"></i> Swipe left/right or use buttons to navigate months
    </div>

    <div class="legend">
      <div class="legend-item"><div class="legend-color shortform"></div><span>Shortform</span></div>
      <div class="legend-item"><div class="legend-color ai-shortform"></div><span>AI Shortform</span></div>
      <div class="legend-item"><div class="legend-color ai-carousel"></div><span>AI Carousel</span></div>
      <div class="legend-item"><div class="legend-color real-carousel"></div><span>Real Carousel</span></div>
      <div class="legend-item"><div class="legend-color longform"></div><span>Longform (1Ã—/month)</span></div>
      <div class="legend-item"><div class="legend-color no-post"></div><span>No Post (Analytics Day)</span></div>
    </div>
  </div>

  <!-- Edit Modal -->
  <div class="modal" id="edit-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="modal-title">Edit Content</h2>
        <button class="close-modal" id="close-modal">&times;</button>
      </div>
      <form id="content-form">
        <input type="hidden" id="edit-date"/>
        <input type="hidden" id="edit-market"/>
        <input type="hidden" id="edit-activity-id" />
        <input type="hidden" id="edit-video-url" />

        <div class="form-group">
          <label for="content-type">Content Type</label>
          <select class="form-control" id="content-type" required>
            <option value="">Select Content Type</option>
            <option value="shortform">Shortform</option>
            <option value="ai-shortform">AI Shortform</option>
            <option value="ai-carousel">AI Carousel</option>
            <option value="real-carousel">Real Carousel</option>
            <option value="longform">Longform</option>
            <option value="no-post">No Post</option>
          </select>
        </div>

        <div class="form-group">
          <label for="content-theme"><i class="fas fa-palette"></i> Theme</label>
          <input type="text" class="form-control" id="content-theme" placeholder="Enter content theme...">
        </div>

        <div class="form-group">
          <label for="content-caption"><i class="fas fa-comment"></i> Caption</label>
          <div style="margin-bottom: 10px;">
            <label style="display: inline-block; margin-right: 20px;">
              <input type="radio" name="caption-mode" value="manual" id="caption-manual" checked>
              <i class="fas fa-keyboard"></i> Enter manually
            </label>
            <label style="display: inline-block;">
              <input type="radio" name="caption-mode" value="ai" id="caption-ai">
              <i class="fas fa-robot"></i> Generate with AI
            </label>
          </div>
          <textarea class="form-control" id="content-caption" placeholder="Enter caption text..." rows="3"></textarea>
        </div>

        <div class="form-group">
          <label><i class="fas fa-clock"></i> Scheduled Time (24H)</label>
        <div style="display: flex; align-items: center; gap: 8px;">
          
          <select id="post-time-hour" class="form-control" style="text-align:center; font-weight:bold; cursor:pointer; width: 75px;">
            <option value="00">00</option><option value="01">01</option><option value="02">02</option>
            <option value="03">03</option><option value="04">04</option><option value="05">05</option>
            <option value="06">06</option><option value="07">07</option><option value="08">08</option>
            <option value="09">09</option><option value="10" selected>10</option><option value="11">11</option>
            <option value="12">12</option><option value="13">13</option><option value="14">14</option>
            <option value="15">15</option><option value="16">16</option><option value="17">17</option>
            <option value="18">18</option><option value="19">19</option><option value="20">20</option>
            <option value="21">21</option><option value="22">22</option><option value="23">23</option>
          </select>
          
          <span style="font-weight:bold; font-size:1.2rem;">:</span>
          
          <select id="post-time-minute" class="form-control" style="text-align:center; font-weight:bold; cursor:pointer; width: 75px;">
            <option value="00">00</option><option value="01">01</option><option value="02">02</option><option value="03">03</option><option value="04">04</option>
            <option value="05">05</option><option value="06">06</option><option value="07">07</option><option value="08">08</option><option value="09">09</option>
            <option value="10">10</option><option value="11">11</option><option value="12">12</option><option value="13">13</option><option value="14">14</option>
            <option value="15">15</option><option value="16">16</option><option value="17">17</option><option value="18">18</option><option value="19">19</option>
            <option value="20">20</option><option value="21">21</option><option value="22">22</option><option value="23">23</option><option value="24">24</option>
            <option value="25">25</option><option value="26">26</option><option value="27">27</option><option value="28">28</option><option value="29">29</option>
            <option value="30">30</option><option value="31">31</option><option value="32">32</option><option value="33">33</option><option value="34">34</option>
            <option value="35">35</option><option value="36">36</option><option value="37">37</option><option value="38">38</option><option value="39">39</option>
            <option value="40">40</option><option value="41">41</option><option value="42">42</option><option value="43">43</option><option value="44">44</option>
            <option value="45">45</option><option value="46">46</option><option value="47">47</option><option value="48">48</option><option value="49">49</option>
            <option value="50">50</option><option value="51">51</option><option value="52">52</option><option value="53">53</option><option value="54">54</option>
            <option value="55">55</option><option value="56">56</option><option value="57">57</option><option value="58">58</option><option value="59">59</option>
          </select>

        </div>
        </div>

        <div class="form-group" id="manual-video-section" style="display:none; margin-top:15px; background:#f8f9fa; padding:15px; border-radius:8px; border:1px dashed #ccc;">
          <label style="color:var(--primary);"><i class="fas fa-video"></i> Selected Video</label>
          
          <div id="preview-container" style="margin-bottom:10px; display:none;">
            <div id="video-loading-indicator" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:white; z-index:10;">
              <i class="fas fa-spinner fa-spin" style="font-size:24px;"></i>
            </div>
            <video id="video-player-preview" controls preload="metadata"  style="width:100%; max-height:300px; background:black; border-radius:6px; position:relative;" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';"></video>
            <div id="video-error-message" style="display:none; color:red; text-align:center; padding:10px; background:#f8f9fa; border-radius:6px; margin-top:5px;">
              <i class="fas fa-exclamation-triangle"></i> Unable to load video preview
            </div>
          </div>

          <div style="display:flex; gap:10px;">
            <input type="text" class="form-control" id="selected-filename" readonly placeholder="No video selected" style="background:white;">
            <button type="button" class="btn btn-primary" id="open-picker-btn">
              Choose
            </button>
            <button type="button" class="btn btn-danger" id="clear-video-btn" title="Clear selection">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        </div>

        
        <div class="video-generation-status" id="video-generation-status">
          <div class="status-text">
            <span id="video-generation-text">Generating video from selected image...</span>
          </div>
        </div>

        <!-- Carousel Video Section -->
        <div class="carousel-video-section" id="carousel-video-section" style="display:none; margin-top: 15px; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px dashed #ccc;">
          <label style="color:var(--primary);"><i class="fas fa-film"></i> Carousel Video</label>
          <p style="font-size:0.85rem; color:var(--gray); margin-bottom:10px;">Add a video to your carousel (optional)</p>
          
          <div id="carousel-video-preview" style="display:none; margin-top:10px;">
            <div style="display:flex; flex-direction:column; gap:0; background:#fff; border-radius:8px; overflow:hidden; border: 1px solid #e0e0e0; box-shadow: 0 2px 8px rgba(0,0,0,0.05);">
              
              <div style="width:100%; background:#000; position:relative; text-align:center;">
                  <video id="carousel-video-player" controls preload="metadata" style="width:100%; height:auto; max-height: 400px; display:block; margin: 0 auto;"></video>
              </div>
          
              <div style="display:flex; justify-content: space-between; align-items:center; gap:10px; padding: 12px 15px; background: #fff; border-top: 1px solid #eee;">
                  <div style="flex:1; overflow:hidden; display:flex; align-items:center; gap:10px; color: #333;">
                       <div style="width:36px; height:36px; background:#f0f2f5; border-radius:50%; display:flex; align-items:center; justify-content:center; color:#555; flex-shrink:0;">
                          <i class="fas fa-video"></i>
                       </div>
                       <div style="overflow:hidden; display:flex; flex-direction:column;">
                          <div id="carousel-video-filename" style="font-size:14px; font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">Filename.mp4</div>
                          <span style="font-size:11px; color:#888;">Carousel Video Asset</span>
                       </div>
                  </div>
                  
                  <button type="button" id="clear-carousel-video-btn" style="border:1px solid #dc3545; background:#fff; color:#dc3545; cursor:pointer; padding:8px 12px; border-radius:6px; font-size:13px; font-weight:600; transition:all 0.2s;" onmouseover="this.style.background='#dc3545'; this.style.color='white';" onmouseout="this.style.background='white'; this.style.color='#dc3545';">
                    <i class="fas fa-trash-alt" style="margin-right:4px;"></i> Remove
                  </button>
              </div>
          
            </div>
          </div>

          <button type="button" class="btn btn-primary" id="open-carousel-video-picker" style="margin-top: 10px;">
            <i class="fas fa-plus"></i> Add Video to Carousel
          </button>
        </div>

        <!-- Carousel Images Preview Section -->
        <div class="carousel-images-section" id="carousel-images-section" style="display:none; margin-top:15px; background:#f8f9fa; padding:15px; border-radius:8px;">
          <label style="color:var(--primary);"><i class="fas fa-images"></i> Carousel Images</label>
          <div id="carousel-images-preview" class="carousel-images-preview">
            <!-- Images will be rendered here -->
          </div>
        </div>

        <div class="ai-prompt-section" id="ai-prompt-section" style="display:none;">
          <div class="form-group">
            <label for="ai-prompt">AI Generation Prompt</label>
            <textarea class="form-control" id="ai-prompt" placeholder="Describe what you want the AI to generate..."></textarea>
          </div>
        </div>

        <div class="form-group">
          <label>Platform</label>
          <div class="platform-selector">
            <input type="checkbox" id="platform-fb" value="facebook">
            <label for="platform-fb"><i class="fa-brands fa-facebook"></i> Facebook</label>
            
            <input type="checkbox" id="platform-ig" value="instagram">
            <label for="platform-ig"><i class="fa-brands fa-instagram"></i> Instagram</label>
            
            <input type="checkbox" id="platform-tt" value="tiktok">
            <label for="platform-tt"><i class="fa-brands fa-tiktok"></i> TikTok</label>

            <input type="checkbox" id="platform-yt" value="youtube">
            <label for="platform-yt"><i class="fa-brands fa-youtube"></i> YouTube</label>

            <input type="checkbox" id="platform-gg" value="google">
            <label for="platform-gg"><i class="fa-brands fa-google"></i> Google</label>
          </div>
        </div>

        <div class="form-group">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
            <label>Markets</label>
            <button type="button" id="select-all-markets" style="background: none; border: none; color: var(--primary); font-size: 0.85rem; cursor: pointer; text-decoration: underline; padding: 0;">Select All</button>
          </div>
          <div class="market-checkboxes" id="market-checkboxes"></div>
        </div>

        <div class="form-group">
          <label><i class="fas fa-language"></i> Video Translation</label>
          <div style="margin-bottom: 10px;">
            <label style="display: flex; align-items: center; gap: 8px;">
              <input type="checkbox" id="enable-video-translation" style="margin: 0;">
              <span>Translate video to other languages</span>
            </label>
          </div>
          
          <!-- Video Translation Section -->
          <div class="video-translation-section" id="video-translation-section" style="display: none; margin-top: 10px; padding: 15px; background: #fff; border-radius: 8px; border: 1px solid #e9ecef;">
            
            <!-- Video Source Info -->
            <div class="form-group">
              <div style="padding: 15px; background: #f8f9ff; border-radius: 8px; border: 2px solid #667eea;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                  <i class="fas fa-info-circle" style="color: #667eea; font-size: 1.2rem;"></i>
                  <strong style="color: var(--primary);">Video to Translate</strong>
                </div>
                <p style="margin: 0; color: #555; font-size: 0.9rem;">
                  The video selected in <strong>"Selected Video"</strong> section above will be used for translation.
                </p>
                <div id="video-translation-source-info" style="margin-top: 10px; padding: 10px; background: white; border-radius: 6px; display: none;">
                  <div style="display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-video" style="color: #667eea;"></i>
                    <span id="video-translation-source-name" style="font-weight: 600; color: #333;"></span>
                  </div>
                </div>
                <div id="video-translation-no-video-warning" style="margin-top: 10px; padding: 10px; background: #fff3cd; border-radius: 6px; border-left: 4px solid #ffc107; display: none;">
                  <div style="display: flex; align-items: center; gap: 10px;">
                    <i class="fas fa-exclamation-triangle" style="color: #856404;"></i>
                    <span style="color: #856404; font-size: 0.9rem;">Please select a video in the "Selected Video" section first.</span>
                  </div>
                </div>
              </div>
            </div>

            <!-- Email Input -->
            <div class="form-group">
              <label style="font-weight: 600; color: var(--primary);"><i class="fas fa-envelope"></i> Email for Results <span style="font-weight: 400; color: #6c757d;">(Optional)</span></label>
              <input type="email" class="form-control" id="video-translation-email" placeholder="your.email@example.com">
            </div>

            <!-- Language Selection -->
            <div class="form-group">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <label style="font-weight: 600; color: var(--primary);"><i class="fas fa-globe"></i> Select Target Languages:</label>
                <button type="button" id="select-all-translation-languages" style="background: none; border: none; color: var(--primary); font-size: 0.85rem; cursor: pointer; text-decoration: underline; padding: 0;">Select All</button>
              </div>
              <div class="language-checkboxes" id="translation-language-checkboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; max-height: 200px; overflow-y: auto; padding: 10px; background: #f8f9fa; border-radius: 6px;">
                <label style="display: flex; align-items: center; gap: 6px; padding: 6px; cursor: pointer; border-radius: 4px; transition: all 0.2s;" class="translation-lang-option">
                  <input type="checkbox" value="English" style="margin: 0;">
                  <span>ðŸ‡ºðŸ‡¸ English</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; padding: 6px; cursor: pointer; border-radius: 4px; transition: all 0.2s;" class="translation-lang-option">
                  <input type="checkbox" value="Japanese" style="margin: 0;">
                  <span>ðŸ‡¯ðŸ‡µ Japanese</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; padding: 6px; cursor: pointer; border-radius: 4px; transition: all 0.2s;" class="translation-lang-option">
                  <input type="checkbox" value="Tamil" style="margin: 0;">
                  <span>ðŸ‡®ðŸ‡³ Tamil</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; padding: 6px; cursor: pointer; border-radius: 4px; transition: all 0.2s;" class="translation-lang-option">
                  <input type="checkbox" value="Korean" style="margin: 0;">
                  <span>ðŸ‡°ðŸ‡· Korean</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; padding: 6px; cursor: pointer; border-radius: 4px; transition: all 0.2s;" class="translation-lang-option">
                  <input type="checkbox" value="Hindi" style="margin: 0;">
                  <span>ðŸ‡®ðŸ‡³ Hindi</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; padding: 6px; cursor: pointer; border-radius: 4px; transition: all 0.2s;" class="translation-lang-option">
                  <input type="checkbox" value="Bengali" style="margin: 0;">
                  <span>ðŸ‡§ðŸ‡© Bengali</span>
                </label>                
                <label style="display: flex; align-items: center; gap: 6px; padding: 6px; cursor: pointer; border-radius: 4px; transition: all 0.2s;" class="translation-lang-option">
                  <input type="checkbox" value="Marathi" style="margin: 0;">
                  <span>ðŸ‡®ðŸ‡³ Marathi</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; padding: 6px; cursor: pointer; border-radius: 4px; transition: all 0.2s;" class="translation-lang-option">
                  <input type="checkbox" value="French" style="margin: 0;">
                  <span>ðŸ‡«ðŸ‡· French</span>
                </label>
                <label style="display: flex; align-items: center; gap: 6px; padding: 6px; cursor: pointer; border-radius: 4px; transition: all 0.2s;" class="translation-lang-option">
                  <input type="checkbox" value="German" style="margin: 0;">
                  <span>ðŸ‡©ðŸ‡ª German</span>
                </label>
              </div>
            </div>

            <!-- Start Translation Button -->
            <button type="button" class="btn btn-primary" id="start-video-translation" disabled style="width: 100%; margin-top: 10px; padding: 12px; font-size: 1.1rem;">
              <i class="fas fa-language"></i> Start Translation
            </button>

            <!-- Translation Progress -->
            <div id="video-translation-progress" style="display: none; margin-top: 20px;">
              <h4 style="color: var(--primary); margin-bottom: 15px;"><i class="fas fa-spinner fa-spin"></i> Translation Progress</h4>
              <div id="video-translation-progress-container"></div>
            </div>

            <!-- Translation Results -->
            <div id="video-translation-results" style="display: none; margin-top: 20px;">
              <h4 style="color: var(--primary); margin-bottom: 15px;"><i class="fas fa-check-circle"></i> Translated Videos</h4>
              <div id="video-translation-results-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 15px;"></div>
            </div>
          </div>
        </div>

        <div class="form-actions">
          <button type="button" class="btn btn-secondary" id="cancel-edit">Cancel</button>
          <button type="button" class="btn btn-danger" id="delete-content">Delete</button>
          <button type="submit" class="btn btn-primary">Save Content</button>
        </div>
      </form>
    </div>
  </div>

  <!-- View Modal (post preview) -->
  <div class="modal" id="view-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="view-title">Content Details</h2>
        <button class="close-modal" id="close-view">&times;</button>
      </div>
      <div id="view-body"></div>
      <div class="form-actions" style="justify-content: flex-end;">
        <button type="button" class="btn btn-primary" id="view-ok">Close</button>
      </div>
    </div>
  </div>

  <!-- Auth Modal -->
  <div class="modal" id="auth-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 class="modal-title" id="auth-title">Editor Login</h2>
        <button class="close-modal" id="close-auth">&times;</button>
      </div>
      <form id="auth-form">
        <div class="form-group">
          <label for="auth-email">Email</label>
          <input type="email" id="auth-email" class="form-control" placeholder="name@aquaverse.com" autocomplete="username" required />
        </div>
        <div class="form-group">
          <label for="auth-password">Password</label>
          <input type="password" id="auth-password" class="form-control" placeholder="Enter password" autocomplete="current-password" required />
        </div>
        <div class="form-actions">
          <button type="button" class="btn btn-secondary" id="cancel-auth">Cancel</button>
          <button type="submit" class="btn btn-primary">Log in</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Video Picker Modal -->
  <div class="modal" id="video-picker-modal">
    <div class="modal-content" style="max-width: 800px; height: 80vh; display:flex; flex-direction:column;">
      <div class="modal-header">
        <h2 class="modal-title">Select Video from Library</h2>
        <button class="close-modal" id="close-picker">&times;</button>
      </div>
      
      <div style="padding-bottom: 10px;">
        <input type="text" id="video-search" class="form-control" placeholder="Search filename...">
      </div>

      <div id="video-list-container" style="flex:1; overflow-y:auto; border:1px solid #eee; border-radius:6px; padding:10px;">
        <div style="text-align:center; padding:20px; color:#999;">Loading videos...</div>
      </div>

      <div class="form-actions" style="margin-top:10px;">
        <button type="button" class="btn btn-secondary" id="cancel-picker">Cancel</button>
      </div>
    </div>
  </div>

  <!-- Carousel Video Picker Modal -->
  <div class="modal" id="carousel-video-picker-modal">
    <div class="modal-content" style="max-width: 800px; height: 80vh; display:flex; flex-direction:column;">
      <div class="modal-header">
        <h2 class="modal-title">Select Video for Carousel</h2>
        <button class="close-modal" id="close-carousel-picker">&times;</button>
      </div>
      
      <div style="padding-bottom: 10px;">
        <input type="text" id="carousel-video-search" class="form-control" placeholder="Search filename...">
      </div>

      <div id="carousel-video-list-container" style="flex:1; overflow-y:auto; border:1px solid #eee; border-radius:6px; padding:10px;">
        <div style="text-align:center; padding:20px; color:#999;">Loading videos...</div>
      </div>

      <div class="form-actions" style="margin-top:10px;">
        <button type="button" class="btn btn-secondary" id="cancel-carousel-picker">Cancel</button>
      </div>
    </div>
  </div>

  <div class="save-notification" id="save-notification">Changes saved successfully!</div>
</div>

<script type="module">
  import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

  const SUPABASE_URL = "https://merpsvkfmjbugrgnwwlq.supabase.co";
  const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1lcnBzdmtmbWpidWdyZ253d2xxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE4NzcyMDksImV4cCI6MjA3NzQ1MzIwOX0.HYqgv5VFQxQ0E1QsxXYLLXu_r6LguyAEaErDSkHUc88";
  const GENERATE_CAROUSEL_WEBHOOK_URL = "https://saschag.app.n8n.cloud/webhook/calendar-carousel";
  const GENERATE_VIDEO_FROM_IMAGE_WEBHOOK_URL = "https://saschag.app.n8n.cloud/webhook/generate-video-from-image";
  const GOOGLE_BUSINESS_WEBHOOK_URL = "https://saschag.app.n8n.cloud/webhook/google-business-post";
  
  const LIST_VIDEOS_WEBHOOK_URL = 'https://merpsvkfmjbugrgnwwlq.supabase.co/functions/v1/list-files';
  // === Canto API Config ===
  const CANTO_API_URL = 'https://columbiapicturesaquaverse.canto.global/api/v1/search'; // TODO: Replace with actual Canto API endpoint
  const CANTO_FOLDER_MAP = {

    //shortform: 'shorts',
    //longform: 'Long form',
    shortform: 'KJP07',
    longform: 'QGKKN',
    videotranslation: 'KJGAJ'  // Folder for translated videos
  };

  const STORAGE_BASE_URL = "https://merpsvkfmjbugrgnwwlq.supabase.co/storage/v1/object/public";

  const BUCKET_SHORTFORM = "ShortForm";
  const BUCKET_SHORTVIDEO = "ShortVideo";
  const BUCKET_CAROUSEL = "carousel-image";
  const BUCKET_CAROUSEL_VIDEO = "carouselvideo";

  const z2 = (n) => String(n).padStart(2, "0");
  const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

  const MARKETS = ['US','Korea','India','France','Japan','UK','Germany','Thailand','Quuba','UAE','Israel','TH (Event)'];
  const norm = s => (s || '').toString().trim().toLowerCase();
  const hasMarketCI = (arr, m) => (arr || []).some(x => norm(x) === norm(m));
  const dedupeMarketsCI = (arr) => { const seen=new Set(); const out=[]; for (const m of arr||[]) { const k=norm(m); if(!seen.has(k)){seen.add(k); out.push(m);} } return out; };
  const toCanonicalMarket = (m) => MARKETS.find(mm => norm(mm) === norm(m)) || m;

  let currentDate = new Date(); // Always start with current month
  let isEditMode = false;
  let currentView = 'global';
  let currentMarket = 'US';
  let currentlyEditingDay = null;

  let monthDataCache = {};
  let pollingInterval = null;
  const table = 'calendars';

  function showNotification(message, type = 'success') {
    const el = document.getElementById('save-notification');
    el.textContent = message;
    el.style.display = 'block';
    el.style.background = type === 'success' ? 'var(--primary)' : 'var(--secondary)';
    setTimeout(() => { el.style.display = 'none'; }, 5000);
  }
// === Canto API Key (replace with your real key, or use env variable in production) ===
  const CANTO_API_KEY = '4f0534d28a7347c7bd18120a9fd5cddd';
  // Fetch video list from Canto for a given folder
 const LIST_CANTO_WEBHOOK_URL = "https://saschag.app.n8n.cloud/webhook/list-videos";

  async function fetchCantoVideos(folder) {
    try {
      // Only allow 'videotranslation' to map to KJGAJ
      let folderCode = folder;
      if (folder === 'videotranslation') {
        folderCode = CANTO_FOLDER_MAP['videotranslation']; // always KJGAJ
      } else if (CANTO_FOLDER_MAP[folder] && folder !== 'videotranslation') {
        // Prevent accidental mapping to KJGAJ from other keys
        folderCode = CANTO_FOLDER_MAP[folder];
        if (folderCode === CANTO_FOLDER_MAP['videotranslation']) {
          throw new Error('Access to KJGAJ is only allowed via videotranslation key');
        }
      }
      console.log(`Fetching Canto videos for folder: ${folder} (resolved: ${folderCode})`);
      const res = await fetch(`${LIST_CANTO_WEBHOOK_URL}?folder=${encodeURIComponent(folderCode)}`);
      if (!res.ok) throw new Error(`Canto proxy error: ${res.status}`);
      const data = await res.json();
      console.log(`Canto response for ${folderCode}:`, data);
      console.log(`First few files:`, data.slice(0, 3));
      if (data.length > 0) {
        console.log(`Fields in first file:`, Object.keys(data[0]));
        console.log(`Sample file data:`, data[0]);
      }
      return data;
    } catch (err) {
      console.error('Error fetching Canto videos:', err);
      return [];
    }
  }



  function getFileUrl(filename, type) {
    if (!filename) return '';
    if (filename.startsWith('http')) return filename; 

    let bucket = "ShortForm"; 

    if (type === 'ai-shortform') bucket = "ShortVideo";
    else if (type === 'ai-carousel') bucket = "carousel-image";
    
    return `${STORAGE_BASE_URL}/${bucket}/${encodeURIComponent(filename)}`;
  }

  async function triggerAICarouselGeneration({ schedule_id, theme, prompt, markets, platforms=[], count = 6 }) {
    try {
      showNotification("Starting AI Carousel generationâ€¦");
      const resp = await fetch(GENERATE_CAROUSEL_WEBHOOK_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          schedule_id,
          date: schedule_id,
          theme,
          prompt,
          markets,
          platforms,
          count
        })
      });

      let data = null;
      try { data = await resp.json(); } catch {}

      const isSuccess = resp.ok || (data && data.message === 'Workflow was started');

      if (!isSuccess) {
        console.error("Generation webhook failed:", data || await resp.text());
        showNotification("AI Carousel generation failed. Check automation logs.", "error");
        return { ok: false, data };
      }

      showNotification("AI Carousel generated and uploaded to Canto.", "success");
      return { ok: true, data };
    } catch (err) {
      console.error(err);
      showNotification("AI Carousel generation failed (network).", "error");
      return { ok: false, error: err?.message || "network_error" };
    }
  }

 async function waitForGeneratedVideo(payloadId, day) {
    let attempts = 0;
    const maxAttempts = 60; // 10 minutes (60 * 10 seconds)
    const interval = 10000; // 10 seconds

    console.log(`ðŸ” Start Polling for Video. Looking for ID part: "${payloadId}"`);
    showNotification('Video generation in progress... Waiting for video.', 'success');

    const statusEl = document.getElementById('video-generation-status');
    const statusText = document.getElementById('video-generation-text');
    statusEl.classList.add('active');

    const poll = setInterval(async () => {
      attempts++;
      statusText.innerHTML = `Checking for video (${attempts}/${maxAttempts})...`;
      console.log(`Attempt ${attempts}: Reading storage...`);

      const { data: files, error } = await supabase
        .storage
        .from(BUCKET_CAROUSEL_VIDEO)
        .list('', { limit: 100, sortBy: { column: 'created_at', order: 'desc' } });

      console.log("ðŸ“‚ Files found in bucket:", files);

      if (error) {
        console.error("âŒ Polling Error (Check Storage Policies):", error);
        return;
      }

      // Look for files that match the payload ID
      // Handle multiple patterns:
      // Pattern 1: act_<id>_<date>.mp4
      // Pattern 2: video_<date>_act_<id>.mp4
      
      const payloadIdPart = payloadId.replace('act_', ''); // Remove 'act_' prefix if present
      const matchedFiles = files.filter(f => {
        const filename = f.name.toLowerCase();
        const idPart = payloadIdPart.toLowerCase();
        
        // Check various patterns for matching
        return (
          filename.includes(`act_${idPart}`) || 
          filename.includes(idPart) ||
          filename.includes(payloadId.toLowerCase())
        );
      });

      console.log(`Looking for: "${payloadId}" or "${payloadIdPart}", Found: ${matchedFiles.length} files`);
      console.log(`Matched files:`, matchedFiles.map(f => f.name));

      if (matchedFiles.length > 0) {
        clearInterval(poll);

        const videoFilename = matchedFiles[0].name; // Get the first matched file
        console.log("âœ… Found Video!", videoFilename);

        // Update the carousel video section in the modal if it's open
        const modal = document.getElementById('edit-modal');
        if (modal.style.display === 'flex') {
          document.getElementById('carousel-video-preview').style.display = 'block';
          document.getElementById('carousel-video-filename').textContent = videoFilename;

          const videoPlayer = document.getElementById('carousel-video-player');
          videoPlayer.src = `${STORAGE_BASE_URL}/${BUCKET_CAROUSEL_VIDEO}/${encodeURIComponent(videoFilename)}`;
        }

        // Update the activity data in database
        const id = monthId(currentDate);
        const { data: sel } = await supabase.from('calendars').select('days').eq('id', id).maybeSingle();

        if (sel && sel.days) {
          const days = { ...sel.days };
          const currentDayArr = days[day] || [];
          const indexToUpdate = currentDayArr.findIndex(item => item.id === payloadId);

          if (indexToUpdate > -1) {
            currentDayArr[indexToUpdate] = {
              ...currentDayArr[indexToUpdate],
              carouselVideo: videoFilename,
              videoGenerated: true,
              videoGeneratedAt: new Date().toISOString()
            };
            days[day] = currentDayArr;

            await supabase.from('calendars').upsert({ id, days }, { onConflict: 'id' });

            monthDataCache = days;
            renderCalendar(currentDate);

            statusText.innerHTML = `
              <i class="fas fa-check-circle" style="color:#28a745; margin-right:8px;"></i> 
              <strong>Complete!</strong> Video added to carousel.
            `;

            setTimeout(() => {
              statusEl.classList.remove('active');
            }, 3000);

            showNotification(`Success! Video generated and added.`);
          }
        }
      }

      if (attempts >= maxAttempts) {
        clearInterval(poll);
        statusText.innerHTML = `
          <i class="fas fa-clock" style="color:#dc3545; margin-right:8px;"></i> 
          <strong>Timeout.</strong> Video generation took too long.
        `;
        setTimeout(() => {
          statusEl.classList.remove('active');
        }, 5000);
        showNotification('Timeout: Video not found. Please check manually.', 'error');
      }
    }, interval);
  }

  // NEW FUNCTION: Generate video from image (simplified - just trigger and wait)
  async function generateVideoFromImage(imageUrl, activityId, imageIndex) {
    try {
      // Show loading status - STEP 1: START
      const statusEl = document.getElementById('video-generation-status');
      const statusText = document.getElementById('video-generation-text');
      statusEl.classList.add('active');
      statusText.innerHTML = '<i class="fas fa-hourglass-start" style="color:#fdbb2d; margin-right:8px;"></i> Checking for existing video...';

      // Get the current activity data
      const activityIdInput = document.getElementById('edit-activity-id').value;
      const day = currentlyEditingDay;

      // Find the activity in the current day's data
      const rawDayData = monthDataCache[day] || null;
      const dayDataArray = Array.isArray(rawDayData) ? rawDayData : (rawDayData ? [rawDayData] : []);
      const activity = dayDataArray.find(item => item.id === activityIdInput);

      if (!activity) {
        throw new Error('Activity not found');
      }

      // Get the date
      const y = currentDate.getFullYear();
      const m = z2(currentDate.getMonth() + 1);
      const d = z2(day);
      const dateStr = `${y}-${m}-${d}`;

      console.log('Checking for existing video:', {
        image_url: imageUrl,
        date: dateStr,
        activity_id: activityIdInput
      });

      // STEP 1: Check if video already exists in the bucket
      const { data: existingFiles, error: listError } = await supabase
        .storage
        .from(BUCKET_CAROUSEL_VIDEO)
        .list('', { limit: 100, sortBy: { column: 'created_at', order: 'desc' } });

      if (listError) {
        console.warn('Could not check storage for existing files, proceeding to generate:', listError);
        // Skip checking and go to generation
      } else {
        console.log('Existing files in bucket:', existingFiles);

        // Extract the ID part from activityIdInput
        const activityIdPart = activityIdInput.replace(/^act_/, '');
        
        // Look for existing video that matches this activity
        const existingVideo = existingFiles.find(f => {
          const filename = f.name.toLowerCase();
          const idPart = activityIdPart.toLowerCase();
          
          // Check various patterns for matching
          return (
            filename.includes(`act_${idPart}`) || 
            filename.includes(idPart) ||
            filename.includes(activityIdInput.toLowerCase())
          );
        });

        console.log('Looking for video with ID part:', activityIdPart, 'Found:', existingVideo ? existingVideo.name : 'none');

        // If video exists, use it
        if (existingVideo) {
          console.log('âœ… Found existing video:', existingVideo.name);
          statusText.innerHTML = `
            <i class="fas fa-check-circle" style="color:#28a745; margin-right:8px;"></i> 
            <strong>Found existing video!</strong> Using: ${existingVideo.name}
          `;

          // Update the carousel video section in the modal if it's open
          const modal = document.getElementById('edit-modal');
          if (modal.style.display === 'flex') {
            document.getElementById('carousel-video-preview').style.display = 'block';
            document.getElementById('carousel-video-filename').textContent = existingVideo.name;

            const videoPlayer = document.getElementById('carousel-video-player');
            videoPlayer.src = `${STORAGE_BASE_URL}/${BUCKET_CAROUSEL_VIDEO}/${encodeURIComponent(existingVideo.name)}`;
          }

          // Update the activity data
          const id = monthId(currentDate);
          const { data: sel } = await supabase.from('calendars').select('days').eq('id', id).maybeSingle();

          if (sel && sel.days) {
            const days = { ...sel.days };
            const currentDayArr = days[day] || [];
            const indexToUpdate = currentDayArr.findIndex(item => item.id === activityIdInput);

            if (indexToUpdate > -1) {
              currentDayArr[indexToUpdate] = {
                ...currentDayArr[indexToUpdate],
                carouselVideo: existingVideo.name,
                videoGenerated: true,
                videoGeneratedAt: new Date().toISOString()
              };
              days[day] = currentDayArr;

              await supabase.from('calendars').upsert({ id, days }, { onConflict: 'id' });

              monthDataCache = days;
              renderCalendar(currentDate);

              statusText.innerHTML = `
                <i class="fas fa-check-circle" style="color:#28a745; margin-right:8px;"></i> 
                <strong>Complete!</strong> Video added to carousel.
              `;

              setTimeout(() => {
                statusEl.classList.remove('active');
              }, 3000);

              showNotification(`Success! Using existing video.`);
            }
          }

          return;
        }
      }

      // STEP 2: No existing video found, generate new one
      statusText.innerHTML = '<i class="fas fa-spinner fa-spin" style="color:#1a2a6c; margin-right:8px;"></i> Video not found. Starting generation...';

      console.log('Sending video generation request:', {
        image_url: imageUrl,
        date: dateStr,
        activity_id: activityIdInput
      });

      // Send webhook request to generate video
      const response = await fetch(GENERATE_VIDEO_FROM_IMAGE_WEBHOOK_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          image_url: imageUrl,
          date: dateStr,
          activity_id: activityIdInput
        })
      });

      console.log('Webhook response status:', response.status);
      console.log('Webhook response headers:', response.headers);

      if (!response.ok) {
        const errorText = await response.text();
        console.error('Webhook error response:', errorText);
        throw new Error(`Webhook failed: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      console.log('Webhook success response:', data);

      if (data.task_id || data.message) {
        // STEP 3: WAITING - Start polling for the generated video
        statusText.innerHTML = '<i class="fas fa-spinner fa-spin" style="color:#1a2a6c; margin-right:8px;"></i> Video generation in progress...';
        // Wait for video using the activity ID
        await waitForGeneratedVideo(activityIdInput, day);
      } else {
        throw new Error('No task ID or confirmation message returned from webhook');
      }

    } catch (error) {
      console.error('Video generation error:', error);
      const statusText = document.getElementById('video-generation-text');
      const statusEl = document.getElementById('video-generation-status');
      statusText.innerHTML = `<i class="fas fa-exclamation-circle" style="color:#dc3545; margin-right:8px;"></i> Video generation failed: ${error.message}`;
      setTimeout(() => {
        statusEl.classList.remove('active');
      }, 5000);
      showNotification('Video generation failed', 'error');
    }
  }

  
  // NEW FUNCTION: Update activity with generated video
  async function updateActivityWithGeneratedVideo(day, activityId, videoFilename, dateObj) {
    try {
      const id = monthId(dateObj);
      const { data: sel } = await supabase
        .from('calendars')
        .select('days')
        .eq('id', id)
        .maybeSingle();
      
      if (sel && sel.days) {
        const days = { ...sel.days };
        const currentDayArr = days[day] || [];
        const indexToUpdate = currentDayArr.findIndex(item => item.id === activityId);

        if (indexToUpdate > -1) {
          currentDayArr[indexToUpdate] = {
            ...currentDayArr[indexToUpdate],
            carouselVideo: videoFilename,
            videoGenerated: true,
            videoGeneratedAt: new Date().toISOString()
          };
          
          days[day] = currentDayArr;
          
          const { error } = await supabase
            .from('calendars')
            .upsert({ id, days }, { onConflict: 'id' });
          
          if (error) {
            console.error('Error saving video to database:', error);
            throw error;
          }
          
          // Update local cache AND re-render calendar
          monthDataCache = days;
          renderCalendar(dateObj);
          updateFolderCounts();
          
          console.log('âœ… Video updated successfully:', videoFilename);
        }
      }
    } catch (error) {
      console.error('Error updating activity with video:', error);
      showNotification('Failed to update activity with video', 'error');
    }
  }

  function buildMarketButtons() {
    const container = document.getElementById('market-selector');
    container.innerHTML = '';
    MARKETS.forEach((m) => {
      const b = document.createElement('button');
      b.className = 'market-btn';
      b.dataset.market = m;
      b.textContent = m;
      b.addEventListener('click', (e) => toggleMarket(e.currentTarget, m));
      container.appendChild(b);
    });
  }

  let selectedMarkets = [];

  function toggleMarket(btnElement, marketName) {
    const canonicalMarket = toCanonicalMarket(marketName);
    const isActive = btnElement.classList.toggle('active');
    const index = selectedMarkets.indexOf(canonicalMarket);

    if (isActive && index === -1) {
      selectedMarkets.push(canonicalMarket);
    } else if (!isActive && index > -1) {
      selectedMarkets.splice(index, 1);
    }
    renderCalendar(currentDate);
  }

  function buildMarketCheckboxes() {
    const box = document.getElementById('market-checkboxes');
    box.innerHTML = '';
    MARKETS.forEach((m) => {
      const id = `market-${m.toLowerCase().replace(/\s+/g,'-')}`;
      const wrap = document.createElement('div');
      wrap.className = 'market-checkbox';
      wrap.innerHTML = `
        <input type="checkbox" id="${id}" value="${m}"/>
        <label for="${id}">${m}</label>
      `;
      box.appendChild(wrap);
    });
  }

  function applyHashRoute() {
    const hash = (location.hash || '').toLowerCase();
    if (hash === '#quuba') {
      currentMarket = 'Quuba'; setView('individual'); buildMarketButtons();
    } else if (hash === '#thailand') {
      currentMarket = 'Thailand'; setView('individual'); buildMarketButtons();
    }
  }

  async function ensureAuthenticated() {
    const { data } = await supabase.auth.getSession();
    if (data?.session) return true;

    return new Promise((resolve) => {
      const authForm = document.getElementById('auth-form');
      const closeBtn = document.getElementById('close-auth');
      const cancelBtn = document.getElementById('cancel-auth');

      openAuthModal();

      const onSubmit = async (e) => {
        e.preventDefault();
        const email = document.getElementById('auth-email').value.trim();
        const pass  = document.getElementById('auth-password').value;
        const { error } = await supabase.auth.signInWithPassword({ email, password: pass });
        if (error) { alert('Invalid credentials or sign-in error.'); return; }
        cleanup(); closeAuthModal();
        document.getElementById('logout-btn').style.display = 'inline-block';
        resolve(true);
      };
      const onCancel = () => { cleanup(); closeAuthModal(); resolve(false); };
      const onEsc = (e) => { if (e.key === 'Escape') onCancel(); };

      function cleanup() {
        authForm.removeEventListener('submit', onSubmit);
        closeBtn.removeEventListener('click', onCancel);
        cancelBtn.removeEventListener('click', onCancel);
        window.removeEventListener('keydown', onEsc);
      }

      authForm.addEventListener('submit', onSubmit);
      closeBtn.addEventListener('click', onCancel);
      cancelBtn.addEventListener('click', onCancel);
      window.addEventListener('keydown', onEsc);
    });
  }

  function openAuthModal() {
    document.getElementById('auth-email').value = '';
    document.getElementById('auth-password').value = '';
    document.getElementById('auth-modal').style.display = 'flex';
    setTimeout(() => document.getElementById('auth-email').focus(), 0);
  }
  function closeAuthModal() { document.getElementById('auth-modal').style.display = 'none'; }

  (async () => {
    const { data: authState } = await supabase.auth.getSession();
    document.getElementById('logout-btn').style.display = authState?.session ? 'inline-block' : 'none';
    supabase.auth.onAuthStateChange((_event, session) => {
      document.getElementById('logout-btn').style.display = session ? 'inline-block' : 'none';
    });
  })();

  document.getElementById('logout-btn')?.addEventListener('click', async () => {
    if (isEditMode) toggleEditMode();
    await supabase.auth.signOut();
    showNotification('Signed out.');
  });

  function monthId(dateObj) {
    const y = dateObj.getFullYear();
    const m = String(dateObj.getMonth()+1).padStart(2,'0');
    return `${y}-${m}`;
  }

  async function upsertEmptyMonthIfMissing(dateObj) {
    const id = monthId(dateObj);
    const { data, error } = await supabase
      .from(table)
      .select('id')
      .eq('id', id)
      .maybeSingle();

    if (error && error.code !== 'PGRST116') {
      console.error('Existence check error:', error);
      return;
    }
    if (!data) {
      const { data: sess } = await supabase.auth.getSession();
      if (sess?.session) {
        const { error: insErr } = await supabase.from(table).upsert({ id, days: {} }, { onConflict: 'id' });
        if (insErr) console.error('Create empty month error:', insErr);
      }
    }
  }

  async function bindMonth(dateObj) {
    if (pollingInterval) {
      clearInterval(pollingInterval);
      pollingInterval = null;
    }

    const id = monthId(dateObj);
    await upsertEmptyMonthIfMissing(dateObj);

    const { data, error } = await supabase
      .from(table)
      .select('days')
      .eq('id', id)
      .maybeSingle();

    if (error) { console.error(error); monthDataCache = {}; }
    else { monthDataCache = (data && data.days) || {}; }

    renderCalendar(dateObj);
    updateFolderCounts();

    // Disabled auto-polling - user must manually refresh to see updates
    // pollingInterval = setInterval(async () => {
    //   try {
    //     const { data: pollData, error: pollError } = await supabase
    //       .from(table)
    //       .select('days')
    //       .eq('id', id)
    //       .maybeSingle();

    //     if (!pollError && pollData && pollData.days) {
    //       const newDays = pollData.days;
    //       if (JSON.stringify(newDays) !== JSON.stringify(monthDataCache)) {
    //         monthDataCache = newDays;
    //         renderCalendar(dateObj);
    //         updateFolderCounts();
    //       }
    //     }
    //   } catch (e) {
    //     console.warn("Polling failed:", e);
    //   }
    // }, 30000); // Poll every 30 seconds
  }

  async function writeDay(dateObj, day, payload) {
    const id = monthId(dateObj);
    const { data: sel, error: selErr } = await supabase
      .from(table)
      .select('days')
      .eq('id', id)
      .maybeSingle();

    if (selErr && selErr.code !== 'PGRST116') {
      console.error('Select error:', selErr);
      alert('Could not load current month data (network/permissions).');
      return;
    }

    const days = { ...(sel?.days || {}) };
    days[day] = payload;

    const { error: upErr } = await supabase
      .from(table)
      .upsert({ id, days }, { onConflict: 'id' });

    if (upErr) {
      console.error('Upsert error:', upErr);
      alert('Save failed (permissions or network).');
    } else {
      monthDataCache = days;
      renderCalendar(currentDate);
      updateFolderCounts();
    }
  }

  async function deleteDay(dateObj, day) {
    const id = monthId(dateObj);
    const { data: sel, error: selErr } = await supabase
      .from(table)
      .select('days')
      .eq('id', id)
      .maybeSingle();

    if (selErr && selErr.code !== 'PGRST116') {
      console.error('Select error:', selErr);
      alert('Could not load current month data (network/permissions).');
      return;
    }

    const days = { ...(sel?.days || {}) };
    delete days[day];

    const { error: upErr } = await supabase
      .from(table)
      .upsert({ id, days }, { onConflict: 'id' });

    if (upErr) {
      console.error('Upsert error:', upErr);
      alert('Delete failed (permissions or network).');
    } else {
      monthDataCache = days;
      renderCalendar(currentDate);
      updateFolderCounts();
    }
  }

  /* ===== Helper: fake media per content type (for post preview) ===== */
  function getPlaceholderMedia(content) {
    const type = content?.type || '';
    const base = 'https://placehold.co';

    if (content && content.mediaUrl) {
      let url = content.mediaUrl;
      // Proxy external images to avoid CORS/restriction issues
      if (url.includes('fbcdn.net') || url.includes('cdninstagram.com')) {
        url = `http://localhost:3000/proxy-image?url=${encodeURIComponent(url)}`;
      }
      return {
        url: url,
        label: 'Linked asset',
        alt: `${getContentTypeName(type)} media`,
        shape:
          type === 'longform'
            ? 'media-landscape'
            : type.includes('carousel')
            ? 'media-square'
            : 'media-vertical',
      };
    }

    switch (type) {
      case 'ai-shortform':
        return {
          url: `${base}/600x1067?text=AI+Shortform+Preview`,
          label: 'Fake AI shortform video preview',
          alt: 'AI shortform placeholder',
          shape: 'media-vertical',
        };
      case 'shortform':
        return {
          url: `${base}/600x1067?text=Shortform+Preview`,
          label: 'Fake shortform video preview',
          alt: 'Shortform placeholder',
          shape: 'media-vertical',
        };
      case 'ai-carousel':
        return {
          url: `${base}/800x800?text=AI+Carousel+Preview`,
          label: 'Fake AI carousel preview',
          alt: 'AI carousel placeholder',
          shape: 'media-square',
        };
      case 'real-carousel':
        return {
          url: `${base}/800x800?text=Real+Carousel+Preview`,
          label: 'Fake real carousel preview',
          alt: 'Real carousel placeholder',
          shape: 'media-square',
        };
      case 'longform':
        return {
          url: `${base}/1280x720?text=Longform+Video+Preview`,
          label: 'Fake longform video preview',
          alt: 'Longform video placeholder',
          shape: 'media-landscape',
        };
      case 'no-post':
        return {
          url: `${base}/800x400?text=Analytics+%2F+No+Post`,
          label: 'Analytics / no-post day',
          alt: 'No post placeholder',
          shape: 'media-landscape',
        };
      default:
        return {
          url: `${base}/800x800?text=Content+Preview`,
          label: 'Generic content preview',
          alt: 'Content placeholder',
          shape: 'media-square',
        };
    }
  }

  function openViewModal(day) {
    const month = currentDate.getMonth() + 1;
    const year = currentDate.getFullYear();
    const viewTitle = document.getElementById('view-title');
    viewTitle.textContent = `Content Details - ${day}/${month}/${year}`;

    const rawDayData = monthDataCache?.[day] || null;
    const dayDataArray = Array.isArray(rawDayData) ? rawDayData : (rawDayData ? [rawDayData] : []);

    const body = document.getElementById('view-body');
    body.innerHTML = '';

    if (dayDataArray.length === 0) {
      body.innerHTML = `<p><strong>No content scheduled</strong> for this day.</p>`;
    } else {
      dayDataArray.forEach((content, index) => {
        if (!content) return;

        const markets = (content.markets || []).map(toCanonicalMarket).join(', ') || '-';
        
        let platforms = [];
        if (Array.isArray(content.platform)) platforms = content.platform;
        else if (content.platform) platforms = [content.platform];

        const platformIcons = platforms.map(p => {
            if (p.toLowerCase() === 'facebook') return `<i class="fa-brands fa-facebook" style="color:#1877F2;"></i>`;
            if (p.toLowerCase() === 'instagram') return `<i class="fa-brands fa-instagram" style="color:#E4405F;"></i>`;
            if (p.toLowerCase() === 'tiktok') return `<i class="fa-brands fa-tiktok" style="color:#000000;"></i>`;
            if (p.toLowerCase() === 'youtube') return `<i class="fa-brands fa-youtube" style="color:#FF0000;"></i>`;
            if (p.toLowerCase() === 'google') return `<i class="fa-brands fa-google" style="color:#4285F4;"></i>`;
            return `<span>${p}</span>`;
        }).join(' ');

        let mediaHtml = '';

        if ((content.type === 'ai-carousel' || content.type === 'real-carousel')) {
          let videoHtml = '';
          let imagesHtml = '';
        
        if (content.carouselVideo) {
          
          const videoUrl = `${STORAGE_BASE_URL}/${BUCKET_CAROUSEL_VIDEO}/${encodeURIComponent(content.carouselVideo)}`;
          
          videoHtml = `
            <div class="preview-block">
              <div class="media-preview">
                <div class="media-frame media-square" style="background:black;">
                  <video controls style="width:100%; height:100%; object-fit:contain;">
                    <source src="${videoUrl}" type="video/mp4">
                    Your browser does not support the video tag.
                  </video>
                </div>
                <div class="media-label">
                  <i class="fa-solid fa-file-video"></i> <span>Carousel Video: ${content.carouselVideo}</span>
                </div>
              </div>
            </div>
          `;
        }
          
          // Add images if exist
          if (content.images && content.images.length > 0) {
            const imagesGrid = content.images.map(filename => {
              const cleanName = filename.replace('carousel-image/', '').replace('carousel-image\\', '');
              const url = `${STORAGE_BASE_URL}/${BUCKET_CAROUSEL}/${encodeURIComponent(cleanName)}`;
              
              return `
                <div class="carousel-image-item">
                  <img src="${url}" alt="Carousel image" 
                    onerror="this.src='https://placehold.co/100x100?text=Error';">
                </div>
              `;
            }).join('');

            imagesHtml = `
              <div class="preview-block">
                <div class="media-label" style="margin-bottom:5px;">
                  <i class="fa-solid fa-images"></i> Generated Assets (${content.images.length})
                </div>
                <div class="carousel-images-grid">
                  ${imagesGrid}
                </div>
              </div>
            `;
          }
          
          mediaHtml = videoHtml + imagesHtml;
        }
        // Handle shortform and longform videos
        else if (content.type.includes('shortform') || content.type === 'longform') {
            let finalVideoUrl = content.videoUrl;

            if (!finalVideoUrl && content.fileName) {
                finalVideoUrl = getFileUrl(content.fileName, content.type);
            }

            if (finalVideoUrl) {
               mediaHtml = `
                 <div class="preview-block">
                   <div class="media-preview">
                     <div class="media-frame media-vertical" style="background:black;">
                       <video controls style="width:100%; height:100%; object-fit:contain;">
                         <source src="${finalVideoUrl}" type="video/mp4">
                         Your browser does not support the video tag.
                       </video>
                     </div>
                     <div class="media-label">
                       <i class="fa-solid fa-file-video"></i> <span>${content.fileName}</span>
                     </div>
                   </div>
                 </div>`;
            }
        }

        if (!mediaHtml) {
           const media = getPlaceholderMedia(content);
           mediaHtml = `
              <div class="preview-block">
                <div class="media-preview">
                  <div class="media-frame ${media.shape}">
                    <img src="${media.url}" alt="${media.alt}" loading="lazy" onerror="this.src='https://placehold.co/100x100?text=Error';" />
                  </div>
                  <div class="media-label"><i class="fa-solid fa-photo-film"></i> <span>${media.label}</span></div>
                </div>
              </div>`;
        }
  
        // Check for translated videos (support both new and legacy field names)
        let translatedVideosHtml = '';
        const translatedVideosData = content.translatedVideos || content.videoTranslations;
        
        console.log(`[View Modal] Content for activity ${index + 1}:`, {
          hasTranslatedVideos: !!content.translatedVideos,
          hasVideoTranslations: !!content.videoTranslations,
          data: translatedVideosData
        });
        
        if (translatedVideosData && typeof translatedVideosData === 'object' && Object.keys(translatedVideosData).length > 0) {
          console.log(`[View Modal] Rendering ${Object.keys(translatedVideosData).length} translated videos`);
          
          const translatedItems = Object.entries(translatedVideosData)
            .map(([lang, videoInfo]) => {
              const videoUrl = videoInfo?.url || videoInfo || '';
              const markets = videoInfo?.markets || [];
              const langFlag = getLangFlag(lang);
              const marketsDisplay = markets.length > 0 
                ? `<div style="margin-top: 8px; font-size: 0.85rem; color: #6c757d;">
                     <i class="fas fa-globe"></i> ${markets.join(', ')}
                   </div>`
                : '';
              console.log(`[View Modal] ${lang}: ${videoUrl}, Markets:`, markets);
              return `
                <div style="background: #f8f9fa; padding: 10px; border-radius: 8px; margin: 5px 0;">
                  <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                    <span style="font-size: 1.2rem;">${langFlag}</span>
                    <strong>${lang}</strong>
                  </div>
                  <video controls style="width: 100%; max-width: 300px; border-radius: 6px; background: black;">
                    <source src="${videoUrl}" type="video/mp4">
                    Your browser does not support the video tag.
                  </video>
                  ${marketsDisplay}
                </div>
              `;
            }).join('');
          
          translatedVideosHtml = `
            <div class="form-group" style="margin-top: 15px;">
              <label><i class="fas fa-language"></i> Translated Videos</label>
              <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 10px;">
                ${translatedItems}
              </div>
            </div>
          `;
        }

        const aiBlock = (content.type === 'ai-carousel' && content.aiPrompt) 
            ? `<div class="form-group" style="margin-top:10px;"><label>AI Prompt</label><div class="form-control" style="background:#f9f9f9;">${content.aiPrompt}</div></div>` 
            : '';

        // Add checkbox for marking post status next to title
        const isPosted = content.markedAsPosted === true;
        const checkboxHtml = `
          <label style="display: inline-flex; align-items: center; gap: 8px; cursor: pointer; margin-left: 15px; font-size: 0.9rem;">
            <input type="checkbox" ${isPosted ? 'checked' : ''} 
                   onchange="toggleActivityPosted('${content.id}', this.checked)" style="transform: scale(1.1);">
            <span style="font-weight: 600; color: ${isPosted ? '#28a745' : '#6c757d'};">
              <i class="fas ${isPosted ? 'fa-check-circle' : 'fa-circle'}"></i> 
              Posted
            </span>
          </label>
        `;

        const timeDisplay = content.postTime ? `<span class="preview-meta-pill"><i class="far fa-clock"></i> <strong>Time:</strong> ${content.postTime}</span>` : '';

        // Caption display with AI indicator
        let captionHtml = '';
        if (content.caption) {
          const captionMode = content.captionMode || 'manual';
          const captionLabel = captionMode === 'ai' 
            ? '<i class="fas fa-robot"></i> Caption (AI Generated)' 
            : '<i class="fas fa-comment"></i> Caption';
          captionHtml = `<div class="form-group"><label>${captionLabel}</label><div class="form-control" style="background:#f9f9f9; white-space: pre-wrap;">${content.caption}</div></div>`;
        }

        body.innerHTML += `
          ${index > 0 ? '<hr style="margin: 20px 0; border-top: 1px solid #eee;">' : ''}
          <h3 class="preview-title-activity" style="display: flex; align-items: center; flex-wrap: wrap;">
            Activity ${index + 1}: ${getContentTypeName(content.type)}
            ${checkboxHtml}
          </h3>
          ${mediaHtml}
          <div class="form-group"><label>Theme</label><div class="form-control preview-theme">${content.theme || '-'}</div></div>
          ${captionHtml}
          <div class="preview-meta-row">
             <div class="preview-meta-pill"><i class="fa-solid fa-globe"></i> <strong>Markets:</strong> ${markets}</div>
             <div class="preview-meta-pill"><i class="fa-solid fa-share-nodes"></i> <strong>Platforms:</strong> ${platformIcons || '-'}</div>
             ${timeDisplay}
          </div>
          ${aiBlock}
          ${translatedVideosHtml}
        `;
      
      
      });
    }

    const modal = document.getElementById('view-modal');
    modal.style.display = 'flex';
    
    // Reset scroll position to top of modal
    const modalContent = modal.querySelector('.modal-content');
    if (modalContent) {
      modalContent.scrollTop = 0;
    }

    const close = () => { modal.style.display = 'none'; };

    const closeBtn = document.getElementById('close-view');
    const okBtn = document.getElementById('view-ok');

    if(closeBtn) closeBtn.onclick = close;
    if(okBtn) okBtn.onclick = close;

    // Close modal when clicking outside modal-content
    modal.onclick = function(e) {
      if (e.target === modal) close();
    };
  }

  // Function to toggle post status of each activity
  async function toggleActivityPosted(activityId, isPosted) {
    try {
      // Find the day of this activity
      let targetDay = null;
      for (const [day, dayData] of Object.entries(monthDataCache || {})) {
        const dayDataArray = Array.isArray(dayData) ? dayData : (dayData ? [dayData] : []);
        const activityExists = dayDataArray.find(activity => activity.id === activityId);
        if (activityExists) {
          targetDay = day;
          break;
        }
      }

      if (!targetDay) {
        console.error('Activity not found:', activityId);
        return;
      }

      // Update data in cache
      const days = { ...monthDataCache };
      const currentDayArr = days[targetDay] || [];
      const dayDataArray = Array.isArray(currentDayArr) ? currentDayArr : [currentDayArr];
      
      const activityIndex = dayDataArray.findIndex(item => item.id === activityId);
      if (activityIndex > -1) {
        dayDataArray[activityIndex] = {
          ...dayDataArray[activityIndex],
          markedAsPosted: isPosted
        };
        days[targetDay] = dayDataArray;

        // Save to database
        const id = monthId(currentDate);
        await supabase.from('calendars').upsert({ id, days }, { onConflict: 'id' });

        // Update cache and re-render
        monthDataCache = days;
        renderCalendar(currentDate);

        const statusText = isPosted ? 'Posted' : 'Unposted';
        showNotification(`Activity marked as ${statusText}`);
        
        // Update checkbox in modal if modal is open
        const modal = document.getElementById('view-modal');
        if (modal && modal.style.display === 'flex') {
          const checkboxInModal = modal.querySelector(`input[onchange*="${activityId}"]`);
          if (checkboxInModal) {
            checkboxInModal.checked = isPosted;
            const labelSpan = checkboxInModal.parentElement.querySelector('span');
            if (labelSpan) {
              labelSpan.style.color = isPosted ? '#28a745' : '#6c757d';
              labelSpan.innerHTML = `<i class="fas ${isPosted ? 'fa-check-circle' : 'fa-circle'}"></i> Posted`;
            }
          }
        }
      }
    } catch (error) {
      console.error('Error updating post status:', error);
      showNotification('Failed to update post status', 'error');
    }
  }

  // Make function accessible from outside
  window.toggleActivityPosted = toggleActivityPosted;

  function updateSelectAllButton() {
    const checkboxes = document.querySelectorAll('#market-checkboxes input[type="checkbox"]');
    const allChecked = Array.from(checkboxes).every(cb => cb.checked);
    const button = document.getElementById('select-all-markets');
    if (button) {
      button.textContent = allChecked ? 'Deselect All' : 'Select All';
    }
  }

  document.addEventListener('DOMContentLoaded', async () => {
    buildMarketButtons();
    buildMarketCheckboxes();
    applyHashRoute();
    await bindMonth(currentDate);
    setupEventListeners();
    initVideoTranslation();
  });

  function setupEventListeners() {
    document.getElementById('prev-month').addEventListener('click', () => changeMonth(-1));
    document.getElementById('next-month').addEventListener('click', () => changeMonth(1));
    document.getElementById('global-view').addEventListener('click', () => setView('global'));
    document.getElementById('individual-view').addEventListener('click', () => setView('individual'));
    document.getElementById('close-modal').addEventListener('click', closeModal);
    document.getElementById('cancel-edit').addEventListener('click', closeModal);
    document.getElementById('delete-content').addEventListener('click', deleteContent);
    document.getElementById('content-form').addEventListener('submit', saveContent);
    document.getElementById('content-type').addEventListener('change', function() {
      const val = this.value;

      if (val === 'shortform') {
          window.CURRENT_BUCKET = "ShortForm";
      } else if (val === 'ai-shortform') {
          window.CURRENT_BUCKET = "ShortVideo";
      } else {
          window.CURRENT_BUCKET = null;
      }

      document.getElementById('ai-prompt-section').style.display =
          (val === 'ai-carousel') ? 'block' : 'none';

      document.getElementById('manual-video-section').style.display =
          (val.includes('shortform') || val === 'longform')
          ? 'block'
          : 'none';

      // Show carousel video section for carousel types
      document.getElementById('carousel-video-section').style.display =
          (val === 'ai-carousel' || val === 'real-carousel')
          ? 'block'
          : 'none';

      // Show carousel images section for carousel types
      document.getElementById('carousel-images-section').style.display =
          (val === 'ai-carousel' || val === 'real-carousel')
          ? 'block'
          : 'none';
    });

    // Carousel video picker
    document.getElementById('open-carousel-video-picker').addEventListener('click', openCarouselVideoPicker);
    document.getElementById('clear-carousel-video-btn').addEventListener('click', clearCarouselVideo);
    document.getElementById('close-carousel-picker').addEventListener('click', () => document.getElementById('carousel-video-picker-modal').style.display = 'none');
    document.getElementById('cancel-carousel-picker').addEventListener('click', () => document.getElementById('carousel-video-picker-modal').style.display = 'none');

    const calRoot = document.getElementById('calendar');

    calRoot.addEventListener('click', (e) => {
      const dayCell = e.target.closest('.calendar-day');
      if (!dayCell) return;
      const day = parseInt(dayCell.dataset.day, 10);
      if (!day) return;

      if (isEditMode) {
        const activityBlock = e.target.closest('.activity-block');
        if (activityBlock) {
          const activityId = activityBlock.dataset.activityId;
          if (activityId) openEditModal(day, activityId);
          return;
        }
        const isHeaderClick = e.target.closest('.date-number');
        const isAddIconClick = e.target.closest('.edit-indicator');

        if (!isHeaderClick || isAddIconClick) {
          const rawDayData = (monthDataCache && monthDataCache[day]) || null;
          const dayDataArray = Array.isArray(rawDayData) ? rawDayData : (rawDayData ? [rawDayData] : []);

          if (isAddIconClick && dayDataArray.length === 1) {
            const activityId = dayDataArray[0].id || 'legacy_0';
            openEditModal(day, activityId);
          } else {
            openEditModal(day, null);
          }
        }
      } else {
        openViewModal(day);
      }
    });

    calRoot.addEventListener('touchstart', e => { window._tSX = e.changedTouches[0].screenX; }, { passive: true });
    calRoot.addEventListener('touchend', e => {
      if (!window._tSX) return;
      const tEX = e.changedTouches[0].screenX;
      const swipe = (tEX - (window._tSX || 0));
      if (swipe > 50) changeMonth(-1);
      else if (swipe < -50) changeMonth(1);
      window._tSX = null;
    });

    window.addEventListener('hashchange', async () => { applyHashRoute(); renderCalendar(currentDate); });

    document.getElementById('edit-mode').addEventListener('click', async () => {
      if (!isEditMode) {
        const ok = await ensureAuthenticated();
        if (!ok) return;
      }
      toggleEditMode();
    });

    // Select All Markets button
    document.getElementById('select-all-markets').addEventListener('click', () => {
      const checkboxes = document.querySelectorAll('#market-checkboxes input[type="checkbox"]');
      const allChecked = Array.from(checkboxes).every(cb => cb.checked);
      
      checkboxes.forEach(cb => {
        cb.checked = !allChecked;
      });
      
      updateSelectAllButton();
    });

    const mq = window.matchMedia('(max-width: 600px)');
    mq.addEventListener?.('change', () => renderCalendar(currentDate));
  }

  // Check if all translations are complete and update the progress header
function updateOverallTranslationProgressStatus() {
  const selected = videoTranslationState.selectedLanguages || [];
  let allComplete = true;
  selected.forEach(lang => {
    const progressItem = document.getElementById(`translation-progress-${lang}`);
    if (progressItem) {
      const badge = progressItem.querySelector('.translation-status-badge');
      if (!badge || !badge.classList.contains('translation-status-success')) {
        allComplete = false;
      }
    } else {
      allComplete = false;
    }
  });
  const header = document.querySelector('#video-translation-progress h4');
  if (header) {
    if (allComplete && selected.length > 0) {
      header.innerHTML = `<i class="fas fa-check-circle" style="color:#28a745"></i> Translation Progress <span style='color:#28a745;font-weight:600;font-size:1rem;margin-left:8px;'>All Complete</span>`;
    } else {
      header.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Translation Progress`;
    }
  }
}

  function setView(view) {
    currentView = view;
    const calendar = document.getElementById('calendar');
    const globalBtn = document.getElementById('global-view');
    const individualBtn = document.getElementById('individual-view');
    const marketSelector = document.getElementById('market-selector');

    if (view === 'global') {
      calendar.classList.remove('individual-view'); calendar.classList.add('global-view');
      globalBtn.classList.add('active'); individualBtn.classList.remove('active'); marketSelector.style.display = 'none';
      selectedMarkets = [];
    } else {
      calendar.classList.remove('global-view'); calendar.classList.add('individual-view');
      globalBtn.classList.remove('active'); individualBtn.classList.add('active'); marketSelector.style.display = 'flex';

      // No default market selection - user must choose

      document.querySelectorAll('.market-btn').forEach(btn => {
        const canonicalMarket = toCanonicalMarket(btn.dataset.market);
        btn.classList.toggle('active', hasMarketCI(selectedMarkets, canonicalMarket));
      });
    }
    renderCalendar(currentDate);
  }

  function setMarket(market) {
    currentMarket = toCanonicalMarket(market);
    document.querySelectorAll('.market-btn').forEach(btn => {
      btn.classList.toggle('active', norm(btn.dataset.market) === norm(currentMarket));
    });
    renderCalendar(currentDate);
  }

  function changeMonth(direction) {
    currentDate.setMonth(currentDate.getMonth() + direction);
    bindMonth(currentDate);
    renderCalendar(currentDate);
    updateFolderCounts();
    const calendar = document.getElementById('calendar');
    calendar.classList.remove('calendar-fade'); void calendar.offsetWidth; calendar.classList.add('calendar-fade');
  }

  function toggleEditMode() {
    isEditMode = !isEditMode;
    const editBtn = document.getElementById('edit-mode');
    if (isEditMode) {
      editBtn.classList.add('active'); editBtn.innerHTML = '<i class="fas fa-edit"></i> Editing';
      document.getElementById('calendar').classList.add('editable');
    } else {
      editBtn.classList.remove('active'); editBtn.innerHTML = 'Edit Mode';
      document.getElementById('calendar').classList.remove('editable');
    }
    renderCalendar(currentDate);
  }

  function newActivityId() { return 'act_' + Date.now() + Math.random().toString(36).substr(2, 9); }

  async function openEditModal(day, activityId = null) {
    currentlyEditingDay = day;
    const month = currentDate.getMonth();
    const year = currentDate.getFullYear();

    const rawDayData = (monthDataCache && monthDataCache[day]) || null;
    let dayDataArray = Array.isArray(rawDayData) ? rawDayData : (rawDayData ? [rawDayData] : []);

    // Fix legacy ID
    dayDataArray.forEach((item, index) => {
      if (!item.id) item.id = `legacy_${index}`;
    });

    const content = activityId ? dayDataArray.find(item => item.id === activityId) : null;

    // --- Safety Helper: Safe value setting functions (prevent errors) ---
    const setVal = (id, val) => { const el = document.getElementById(id); if(el) el.value = val; };
    const setCheck = (id, val) => { const el = document.getElementById(id); if(el) el.checked = val; };
    const setText = (id, val) => { const el = document.getElementById(id); if(el) el.textContent = val; };
    // -----------------------------------------------------------

    // Set Hidden Fields & Title
    if(document.getElementById('modal-title')) {
        document.getElementById('modal-title').textContent = content
        ? `Edit Content - ${day}/${month+1}/${year}`
        : `Add Content - ${day}/${month+1}/${year}`;
    }
    setVal('edit-date', `${year}-${month}-${day}`);
    setVal('edit-activity-id', content ? content.id : '');

    // Reset Market Checkboxes
    const selected = new Set((content?.markets || []).map(norm));
    document.querySelectorAll('#market-checkboxes input[type="checkbox"]').forEach(cb => {
      cb.checked = selected.size ? selected.has(norm(cb.value)) : false;
    });

    // Update Select All button text
    updateSelectAllButton();

    if (content) {
      
      setVal('content-type', content.type || '');
      setVal('content-theme', content.theme || '');
      
      // Handle caption mode and content
      const isManualMode = content.captionMode === 'manual' || (content.caption && content.caption.trim() && !content.captionMode);
      setCheck('caption-manual', isManualMode);
      setCheck('caption-ai', !isManualMode);
      setVal('content-caption', content.caption || '');
      
      // Update caption field visibility
      toggleCaptionField();
      setVal('ai-prompt', content.aiPrompt || '');

      if (content.postTime) {
          const parts = content.postTime.split(':');
          if (parts.length === 2) {
             setVal('post-time-hour', parts[0]);
             setVal('post-time-minute', parts[1]);
          }
      } else {
          setVal('post-time-hour', '10');
          setVal('post-time-minute', '00');
      }

      // Show/Hide Delete Button
      const delBtn = document.getElementById('delete-content');
      if(delBtn) delBtn.style.display = 'inline-block';

      // Load Platforms
      let platforms = Array.isArray(content.platform) ? content.platform : (content.platform ? [content.platform] : []);
      const platformSet = new Set(platforms);
      setCheck('platform-fb', platformSet.has('facebook'));
      setCheck('platform-ig', platformSet.has('instagram'));
      setCheck('platform-tt', platformSet.has('tiktok'));
      setCheck('platform-yt', platformSet.has('youtube'));
      setCheck('platform-gg', platformSet.has('google'));

      // Load Translation Settings (Old text translation - keeping for backward compatibility)
      const enableTranslationElem = document.getElementById('enable-translation');
      if (enableTranslationElem && content.translation) {
        setCheck('enable-translation', content.translation.enabled || false);
        
        // Handle both old single language format and new multiple languages format
        const languages = content.translation.languages || 
                         (content.translation.language ? [content.translation.language] : []);
        
        // Reset all language checkboxes first
        const langCheckboxes = document.querySelectorAll('#language-checkboxes input[type="checkbox"]');
        if (langCheckboxes.length > 0) {
          langCheckboxes.forEach(cb => {
            cb.checked = languages.includes(cb.value);
          });
        }
      } else if (enableTranslationElem) {
        setCheck('enable-translation', false);
        // Reset all language checkboxes
        const langCheckboxes = document.querySelectorAll('#language-checkboxes input[type="checkbox"]');
        if (langCheckboxes.length > 0) {
          langCheckboxes.forEach(cb => {
            cb.checked = false;
          });
        }
      }
      // Update translation section visibility and select all button (only if elements exist)
      if (enableTranslationElem) {
        toggleTranslationSection();
        updateSelectAllLanguagesButton();
      }

      // --- Carousel Video ---
      if ((content.type === 'ai-carousel' || content.type === 'real-carousel') && content.carouselVideo) {
        const preview = document.getElementById('carousel-video-preview');
        const player = document.getElementById('carousel-video-player');
        if(preview) preview.style.display = 'block';
        setText('carousel-video-filename', content.carouselVideo);
        if(player) {
            // Use the correct bucket for carousel videos
            player.src = `${STORAGE_BASE_URL}/${BUCKET_CAROUSEL_VIDEO}/${encodeURIComponent(content.carouselVideo)}`;
        }
      } else {
        const preview = document.getElementById('carousel-video-preview');
        if(preview) preview.style.display = 'none';
      }

      // --- Carousel Images ---
      if ((content.type === 'ai-carousel' || content.type === 'real-carousel') && content.images && content.images.length > 0) {
        const imagesContainer = document.getElementById('carousel-images-preview');
        if (imagesContainer) {
            imagesContainer.innerHTML = '';
            const imagesGrid = document.createElement('div');
            imagesGrid.className = 'carousel-images-grid';
            
            content.images.forEach((filename, index) => {
              const cleanName = filename.replace('carousel-image/', '').replace('carousel-image\\', '');
              const url = `${STORAGE_BASE_URL}/${BUCKET_CAROUSEL}/${encodeURIComponent(cleanName)}`;
              const imageItem = document.createElement('div');
              imageItem.className = 'carousel-image-item';
              imageItem.innerHTML = `
                <img src="${url}" alt="Carousel image" onerror="this.src='https://placehold.co/100x100?text=Error';">
                <button class="generate-video-btn" data-image-url="${url}" data-image-index="${index}">
                  <i class="fas fa-video"></i> Generate Video
                </button>
                <button class="delete-image-btn" data-image-filename="${cleanName}" data-image-index="${index}" style="position: absolute; top: 5px; right: 5px; background: rgba(220, 53, 69, 0.9); color: white; border: none; padding: 5px; border-radius: 3px; cursor: pointer;">
                  <i class="fas fa-trash"></i>
                </button>
              `;
              imagesGrid.appendChild(imageItem);
            });
            imagesContainer.appendChild(imagesGrid);
            
            // Add event listeners to generate video buttons - with proper error handling
            setTimeout(() => {
              imagesContainer.querySelectorAll('.generate-video-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  console.log('Generate video button clicked');
                  
                  const imageUrl = btn.dataset.imageUrl;
                  const imageIndex = btn.dataset.imageIndex;
                  const activityId = content.id;
                  
                  // Add loading state to button
                  const originalHTML = btn.innerHTML;
                  btn.classList.add('loading');
                  
                  btn.disabled = true;
                  
                  try {
                    await generateVideoFromImage(imageUrl, activityId, imageIndex);
                  } catch (error) {
                    console.error('Error in generate video handler:', error);
                    showNotification('Failed to start video generation', 'error');
                  } finally {
                    // Reset button state after a delay
                    setTimeout(() => {
                      btn.classList.remove('loading');
                      btn.innerHTML = originalHTML;
                      btn.disabled = false;
                    }, 2000);
                  }
                });
              });

              imagesContainer.querySelectorAll('.delete-image-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  if (!confirm('Are you sure you want to delete this image?')) return;
                  const filename = btn.dataset.imageFilename;
                  const index = parseInt(btn.dataset.imageIndex);
                  if (await deleteFileFromStorage(BUCKET_CAROUSEL, filename)) {
                    const day = currentlyEditingDay;
                    const activityId = document.getElementById('edit-activity-id').value;
                    const id = monthId(currentDate);
                    supabase.from('calendars').select('days').eq('id', id).maybeSingle().then(({ data: sel }) => {
                      if (sel && sel.days) {
                        const days = { ...sel.days };
                        const currentDayArr = days[day] || [];
                        const activityIndex = currentDayArr.findIndex(item => item.id === activityId);
                        if (activityIndex > -1) {
                          const activity = currentDayArr[activityIndex];
                          if (activity.images && activity.images[index]) {
                            activity.images.splice(index, 1);
                            days[day] = currentDayArr;
                            supabase.from('calendars').upsert({ id, days }, { onConflict: 'id' }).then(() => {
                              monthDataCache = days;
                              openEditModal(day, activityId);
                            });
                          }
                        }
                      }
                    });
                  }
                });
              });
            }, 100);
        }
        const imgSec = document.getElementById('carousel-images-section');
        if(imgSec) imgSec.style.display = 'block';
      } else {
        // Reset Images if none
        const imgSec = document.getElementById('carousel-images-section');
        if(imgSec) imgSec.style.display = 'block';
        const imgPrev = document.getElementById('carousel-images-preview');
        if(imgPrev) imgPrev.innerHTML = '<p style="color:var(--gray); font-style:italic;">No images generated yet</p>';
      }

    } else {
      
      setVal('content-type', '');
      setVal('content-theme', '');
      setVal('content-caption', '');
      setVal('ai-prompt', '');
      setVal('post-time-hour', '10');
      setVal('post-time-minute', '00');
      
      // Default to AI caption mode for new content
      setCheck('caption-manual', false);
      setCheck('caption-ai', true);
      toggleCaptionField();

      setCheck('platform-fb', false);
      setCheck('platform-ig', false);
      setCheck('platform-tt', false);
      setCheck('platform-yt', false);
      setCheck('platform-gg', false);

      // Reset Translation Settings for new content (only if elements exist)
      const enableTranslationElem = document.getElementById('enable-translation');
      if (enableTranslationElem) {
        setCheck('enable-translation', false);
        const langCheckboxes = document.querySelectorAll('#language-checkboxes input[type="checkbox"]');
        if (langCheckboxes.length > 0) {
          langCheckboxes.forEach(cb => {
            cb.checked = false;
          });
        }
        toggleTranslationSection();
        updateSelectAllLanguagesButton();
      }

      const delBtn = document.getElementById('delete-content');
      if(delBtn) delBtn.style.display = 'none';
      
      const vidPrev = document.getElementById('carousel-video-preview');
      if(vidPrev) vidPrev.style.display = 'none';
      
      const imgSec = document.getElementById('carousel-images-section');
      if(imgSec) imgSec.style.display = 'block'; // Show section but empty
      const imgPrev = document.getElementById('carousel-images-preview');
      if(imgPrev) imgPrev.innerHTML = '<p style="color:var(--gray); font-style:italic;">No images generated yet</p>';
    }

    // Toggle Sections Visibility
    const type = document.getElementById('content-type') ? document.getElementById('content-type').value : '';
    const aiPromptSec = document.getElementById('ai-prompt-section');
    const manualVidSec = document.getElementById('manual-video-section');
    const carVidSec = document.getElementById('carousel-video-section');
    const carImgSec = document.getElementById('carousel-images-section');

    if(aiPromptSec) aiPromptSec.style.display = (type === 'ai-carousel') ? 'block' : 'none';
    if(manualVidSec) manualVidSec.style.display = (type.includes('shortform') || type === 'longform') ? 'block' : 'none';
    if(carVidSec) carVidSec.style.display = (type === 'ai-carousel' || type === 'real-carousel') ? 'block' : 'none';
    if(carImgSec) carImgSec.style.display = (type === 'ai-carousel' || type === 'real-carousel') ? 'block' : 'none';

    // Hide video generation status
    document.getElementById('video-generation-status').classList.remove('active');

    const editModal = document.getElementById('edit-modal');
    editModal.style.display = 'flex';
    // Close modal when clicking outside modal-content
    editModal.onclick = function(e) {
      if (e.target === editModal) closeModal();
    };

    // Handle Manual Video (Non-Carousel)
    if (manualVidSec && content && content.type && (content.type.includes('shortform') || content.type === 'longform')) {
        const fName = content.fileName || '';
        const videoUrl = content.videoUrl || '';
        setVal('selected-filename', fName);
        setVal('edit-video-url', videoUrl);
        
        const preview = document.getElementById('preview-container');
        const player = document.getElementById('video-player-preview');
        const errorMsg = document.getElementById('video-error-message');
        const loadingIndicator = document.getElementById('video-loading-indicator');
 
        if((fName || videoUrl) && preview && player) {
            console.log(`Loading existing content:`, { fName, videoUrl, contentType: content.type });
            // Reset video element
            player.style.display = 'block';
            if (errorMsg) errorMsg.style.display = 'none';
            if (loadingIndicator) loadingIndicator.style.display = 'block';
            player.pause();
            player.currentTime = 0;
            
            preview.style.display = 'block';
            console.log(`Loading video for ${content.type}: ${fName}`, { videoUrl: videoUrl || 'none', hasVideoUrl: !!videoUrl });
            
            // For shortform/longform videos, ALWAYS try to get directUrlOriginal from Canto first
            if (content.type.includes('shortform') || content.type === 'longform') {
                console.log(`Content type ${content.type} is shortform/longform, trying Canto first`);
                try {
                    const folder = CANTO_FOLDER_MAP[content.type] || CANTO_FOLDER_MAP['shortform'];
                    console.log(`Using Canto folder: ${folder} for content type: ${content.type}`);
                    const cantoFiles = await fetchCantoVideos(folder);
                    const matchingFile = cantoFiles.find(f => f.name === fName);
                    console.log(`Looking for exact match: "${fName}"`);
                    console.log(`Available files:`, cantoFiles.map(f => `"${f.name}"`));
                    
                    // If not found in primary folder, try the other folder
                    if (!matchingFile) {
                        console.log(`File not found in ${folder}, trying other folder`);
                        const otherFolder = (folder === CANTO_FOLDER_MAP['shortform']) ? CANTO_FOLDER_MAP['longform'] : CANTO_FOLDER_MAP['shortform'];
                        console.log(`Trying folder: ${otherFolder}`);
                        const otherCantoFiles = await fetchCantoVideos(otherFolder);
                        const otherMatchingFile = otherCantoFiles.find(f => f.name === fName);
                        if (otherMatchingFile) {
                            console.log(`Found file in other folder:`, otherMatchingFile);
                            folder = otherFolder;
                            cantoFiles = otherCantoFiles;
                            matchingFile = otherMatchingFile;
                        }
                    }
                    
                    // Also try partial match in case of filename differences
                    if (!matchingFile) {
                        const partialMatch = cantoFiles.find(f => f.name.includes(fName.split('.')[0]) || fName.includes(f.name.split('.')[0]));
                        if (partialMatch) {
                            console.log(`Found partial match:`, partialMatch);
                            matchingFile = partialMatch;
                        }
                    }
                    if (matchingFile && matchingFile.directUrlOriginal) {
                        console.log('âœ… Found directUrlOriginal in Canto:', matchingFile.directUrlOriginal);
                        player.src = matchingFile.directUrlOriginal;
                        // Update the stored videoUrl for future use
                        setVal('edit-video-url', matchingFile.directUrlOriginal);
                    } else if (matchingFile && matchingFile.directUrl) {
                        console.log('âš ï¸ Found directUrl in Canto (fallback):', matchingFile.directUrl);
                        player.src = matchingFile.directUrl;
                        setVal('edit-video-url', matchingFile.directUrl);
                    } else if (matchingFile && matchingFile.url) {
                        console.log('âš ï¸ Found url in Canto (fallback):', matchingFile.url);
                        player.src = matchingFile.url;
                        setVal('edit-video-url', matchingFile.url);
                    } else {
                        console.log('âŒ Video not found in Canto or no usable URL fields');
                        console.log('Available fields in matching file:', matchingFile ? Object.keys(matchingFile) : 'no matching file');
                        if (matchingFile) {
                            console.log('Matching file data:', matchingFile);
                            console.error('âŒ Webhook did not send directUrlOriginal - Please update the webhook to send directUrlOriginal');
                            console.log('Expected format:', {name: 'filename.mp4', directUrlOriginal: 'https://...'});
                        }
                        const fallbackUrl = videoUrl || getFileUrl(fName, content.type);
                        player.src = fallbackUrl;
                        console.log('Using Supabase fallback URL:', fallbackUrl);
                    }
                } catch (err) {
                    console.warn('Could not fetch from Canto, using stored videoUrl or Supabase URL:', err);
                    const fallbackUrl = videoUrl || getFileUrl(fName, content.type);
                    player.src = fallbackUrl;
                    console.log('Using fallback URL:', fallbackUrl);
                }
            } else {
                // For other content types, use stored videoUrl or construct Supabase URL
                const fullUrl = videoUrl || getFileUrl(fName, content.type);
                console.log('Using URL for non-shortform content:', fullUrl);
                player.src = fullUrl;
            }
            
            // Handle loading for existing content
            player.onloadedmetadata = () => {
              console.log('Video loaded successfully:', player.src);
              if (loadingIndicator) loadingIndicator.style.display = 'none';
            };
            
            player.onerror = () => {
              console.error('Video failed to load - both Canto and fallback URLs failed');
              player.style.display = 'none';
              if (loadingIndicator) loadingIndicator.style.display = 'none';
              if (errorMsg) errorMsg.style.display = 'block';
            };
        } else if (preview) {
             preview.style.display = 'none';
        }
    } else {
        setVal('selected-filename', '');
        setVal('edit-video-url', '');
        const preview = document.getElementById('preview-container');
        const player = document.getElementById('video-player-preview');
        const errorMsg = document.getElementById('video-error-message');
        const loadingIndicator = document.getElementById('video-loading-indicator');
        if(preview) preview.style.display = 'none';
        if (player) {
            player.pause();
            player.currentTime = 0;
            player.src = '';
            player.style.display = 'block';
        }
        if (errorMsg) errorMsg.style.display = 'none';
        if (loadingIndicator) loadingIndicator.style.display = 'none';
    }

    // Restore saved video translations if they exist
    videoTranslationState.translationResults = {};
    const resultsGrid = document.getElementById('video-translation-results-grid');
    if (resultsGrid) resultsGrid.innerHTML = '';
    const resultsSection = document.getElementById('video-translation-results');
    if (resultsSection) resultsSection.style.display = 'none';

    // Check for translatedVideos (new name) or videoTranslations (legacy name)
    const translatedVideosData = content?.translatedVideos || content?.videoTranslations || {};
    
    if (content && Object.keys(translatedVideosData).length > 0) {
      console.log('ðŸ”„ Restoring video translations:', translatedVideosData);
      
      // Enable video translation checkbox
      const enableVideoTranslationCheckbox = document.getElementById('enable-video-translation');
      if (enableVideoTranslationCheckbox) {
        enableVideoTranslationCheckbox.checked = true;
        // Show the video translation section
        const videoTranslationSection = document.getElementById('video-translation-section');
        if (videoTranslationSection) {
          videoTranslationSection.style.display = 'block';
        }
      }

      // Check the Select Video checkbox (if not already checked)
      const selectVideoCheckbox = document.getElementById('select-canto-video-checkbox');
      if (selectVideoCheckbox && !selectVideoCheckbox.checked && content.fileName) {
        selectVideoCheckbox.checked = true;
        // Trigger the change event to show the video picker section
        selectVideoCheckbox.dispatchEvent(new Event('change'));
      }

      // Update video translation source info
      if (typeof updateVideoTranslationSource === 'function') {
        updateVideoTranslationSource();
      }

      // Restore each translated video
      Object.entries(translatedVideosData).forEach(([lang, videoData]) => {
        // Extract URL and markets from videoData (could be string or object)
        let videoUrl = '';
        let filename = '';
        let markets = [];
        if (typeof videoData === 'string') {
          videoUrl = videoData;
        } else if (videoData && typeof videoData === 'object') {
          videoUrl = videoData.url || videoData.directUrlOriginal || videoData.directUrl || '';
          filename = videoData.filename || '';
          markets = videoData.markets || [];
        }
        
        if (videoUrl) {
          console.log(`âœ… Restoring ${lang}:`, videoUrl, 'Markets:', markets);
          videoTranslationState.translationResults[lang] = {
            url: videoUrl,
            filename: filename,
            markets: markets
          };
            
          // Check the language checkbox
          const langCheckboxes = document.querySelectorAll('#translation-language-checkboxes input[type="checkbox"]');
          langCheckboxes.forEach(cb => {
            if (cb.value === lang) {
              cb.checked = true;
              videoTranslationState.selectedLanguages.add(lang);
            }
          });
        
          addVideoTranslationResultCard(lang, videoUrl);
          
          // Restore market selections after card is added
          if (markets.length > 0) {
            setTimeout(() => {
              const marketsContainer = document.getElementById(`markets-${lang}`);
              if (marketsContainer) {
                marketsContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                  cb.checked = markets.includes(cb.value);
                });
              }
            }, 100);
          }
        } else {
          console.warn(`âš ï¸ No URL found for ${lang}:`, videoData);
        }
      });

      // Update the start translation button state
      if (typeof updateStartTranslationButton === 'function') {
        updateStartTranslationButton();
      }
    }
  }
  function closeModal() {
    document.getElementById('edit-modal').style.display = 'none';
    currentlyEditingDay = null;
    // Hide video generation status
    document.getElementById('video-generation-status').classList.remove('active');
  }

  async function openCarouselVideoPicker() {
  const modal = document.getElementById('carousel-video-picker-modal');
  const container = document.getElementById('carousel-video-list-container');
  const searchInput = document.getElementById('carousel-video-search');

  searchInput.value = ''; 
  modal.style.display = 'flex';
  container.innerHTML = '<div style="text-align:center; margin-top:20px;"><i class="fas fa-spinner fa-spin"></i> Loading Library...</div>';

  try {
    const type = document.getElementById('content-type').value;
    const currentActivityId = document.getElementById('edit-activity-id').value;

    let bucket = BUCKET_CAROUSEL_VIDEO; 
    if (type === 'ai-carousel' || type === 'real-carousel') {
      bucket = "carouselvideo"; 
    }
   
    const res = await fetch(`${LIST_VIDEOS_WEBHOOK_URL}?bucket=${bucket}`);
    if (!res.ok) throw new Error(`API Error: ${res.status}`);
    
    const responseText = await res.text(); // Get response as text first
    let allFiles = [];
    if (responseText.trim()) {
      try {
        allFiles = JSON.parse(responseText); // Parse only if not empty
      } catch (jsonError) {
        console.error('JSON parse error:', jsonError);
        throw new Error('Invalid JSON response from server');
      }
    } else {
      // Don't throw error, return empty array instead
      allFiles = [];
    }

    const usedFilenames = await getUsedFilenames(currentActivityId);
    const availableFiles = allFiles.filter(file => !usedFilenames.has(file.name));
  
    renderCarouselVideoList(availableFiles);

    searchInput.onkeyup = (e) => {
      const term = e.target.value.toLowerCase();
      const filtered = availableFiles.filter(f => f.name.toLowerCase().includes(term));
      renderCarouselVideoList(filtered);
    };

  } catch (err) {
    container.innerHTML = `<div style="color:red; text-align:center;">Error loading videos.<br>${err.message}</div>`;
    console.error(err);
  }
}

  function renderCarouselVideoList(files) {
    const container = document.getElementById('carousel-video-list-container');
    container.innerHTML = '';

    if(!files || files.length === 0) {
        container.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">No videos found.</div>';
        return;
    }

    files.forEach(file => {
      if(file.name === '.emptyFolderPlaceholder') return;
   
      const sizeBytes = file.size || (file.metadata && file.metadata.size) || 0;
      const sizeMB = (sizeBytes / 1024 / 1024).toFixed(2);

      const div = document.createElement('div');
      div.style.cssText = "padding:12px; border-bottom:1px solid #eee; cursor:pointer; display:flex; justify-content:space-between; align-items:center; transition:background 0.2s;";
      div.onmouseover = () => div.style.background = "#f8f9fa";
      div.onmouseout = () => div.style.background = "white";

      div.innerHTML = `
        <div style="pointer-events:none;">
            <i class="fas fa-file-video" style="color:#666; margin-right:10px;"></i>
            <strong>${file.name}</strong>
            <div style="font-size:0.8rem; color:#999; margin-left:26px; margin-top:2px;">Size: ${sizeMB} MB</div>
        </div>
        <button class="btn btn-secondary" style="padding:4px 12px; font-size:0.8rem; pointer-events:none;">Select</button>
      `;
   
      div.onclick = () => selectCarouselVideo(file.name);
      
      container.appendChild(div);
    });
  }

  function selectCarouselVideo(filename) {
    document.getElementById('carousel-video-preview').style.display = 'block';
    document.getElementById('carousel-video-filename').textContent = filename;
    
    const videoPlayer = document.getElementById('carousel-video-player');
    videoPlayer.src = `${STORAGE_BASE_URL}/${BUCKET_CAROUSEL_VIDEO}/${encodeURIComponent(filename)}`;

    document.getElementById('carousel-video-picker-modal').style.display = 'none';
  }

  function clearCarouselVideo() {
    const filename = document.getElementById('carousel-video-filename').textContent.trim();
    if (filename) {
      if (!confirm('Are you sure you want to delete this video from storage?')) return;
      // Delete file
      deleteFileFromStorage(BUCKET_CAROUSEL_VIDEO, filename).then(success => {
        if (success) {
          // Remove from content
          const day = currentlyEditingDay;
          const activityId = document.getElementById('edit-activity-id').value;
          const id = monthId(currentDate);
          supabase.from('calendars').select('days').eq('id', id).maybeSingle().then(({ data: sel }) => {
            if (sel && sel.days) {
              const days = { ...sel.days };
              const currentDayArr = days[day] || [];
              const activityIndex = currentDayArr.findIndex(item => item.id === activityId);
              if (activityIndex > -1) {
                const activity = currentDayArr[activityIndex];
                if (activity.carouselVideo === filename) {
                  delete activity.carouselVideo;
                  delete activity.videoGenerated;
                  delete activity.videoGeneratedAt;
                }
                days[day] = currentDayArr;
                supabase.from('calendars').upsert({ id, days }, { onConflict: 'id' }).then(() => {
                  monthDataCache = days;
                  renderCalendar(currentDate);
                });
              }
            }
          });
        }
      });
    }
    document.getElementById('carousel-video-preview').style.display = 'none';
    document.getElementById('carousel-video-filename').textContent = '';
    document.getElementById('carousel-video-player').src = '';
  }

  async function deleteFileFromStorage(bucket, filename) {
    console.log(`Attempting to delete file: ${filename} from bucket: ${bucket}`);
    try {
      const { error } = await supabase.storage.from(bucket).remove([filename]);
      if (error) {
        console.error('Supabase delete error:', error);
        throw error;
      }
    
      const { data: files } = await supabase.storage.from(bucket).list('', { limit: 100 });
      const stillExists = files.some(f => f.name === filename);
      if (stillExists) {
        console.error('File still exists after delete attempt');
        showNotification('File deletion failed - file still exists', 'error');
        return false;
      }
      
      console.log(`Successfully deleted: ${filename}`);
      showNotification(`File ${filename} deleted from storage.`);
      return true;
    } catch (err) {
      console.error('Error deleting file:', err);
      showNotification('Failed to delete file from storage', 'error');
      return false;
    }
  }

  async function saveContent(e) {
    e.preventDefault();
    const ok = await ensureAuthenticated(); if (!ok) return;

    const getVal = (id) => { const el = document.getElementById(id); return el ? el.value : ''; };
    const getCheck = (id) => { const el = document.getElementById(id); return el ? el.checked : false; };

    const day = currentlyEditingDay;
    const activityId = getVal('edit-activity-id');
    const type = getVal('content-type');
    const theme = getVal('content-theme');
    const isManualCaption = getCheck('caption-manual');
    const caption = isManualCaption ? getVal('content-caption') : null; // Only save caption if manual mode
    const aiPrompt = getVal('ai-prompt');
    const manualFileName = getVal('selected-filename');

    let postTime = '10:00';
    const hhEl = document.getElementById('post-time-hour');
    const mmEl = document.getElementById('post-time-minute');
    const singleTimeEl = document.getElementById('post-time');

    if (hhEl && mmEl) {
       
        postTime = `${hhEl.value}:${mmEl.value}`;
    } else if (singleTimeEl) {
       
        postTime = singleTimeEl.value;
    }
    
    const carouselVideoEl = document.getElementById('carousel-video-filename');
    const carouselPreviewEl = document.getElementById('carousel-video-preview');
    const carouselVideo = (carouselPreviewEl && carouselPreviewEl.style.display !== 'none' && carouselVideoEl) 
      ? carouselVideoEl.textContent 
      : null;

    let selectedMarketsList = [];
    document.querySelectorAll('#market-checkboxes input:checked').forEach(cb => selectedMarketsList.push(toCanonicalMarket(cb.value)));
    selectedMarketsList = dedupeMarketsCI(selectedMarketsList).map(toCanonicalMarket);
    
    if (selectedMarketsList.length === 0) { alert('Please select at least one market'); return; }

    if (!type) { alert('Please select a content type'); return; }
    if (type === 'ai-carousel' && !aiPrompt.trim()) {
      alert('AI Carousel requires an AI Generation Prompt.');
      return;
    }

    // Inventory check
    if (type === 'ai-shortform') {
      const availableCount = await getRealtimeVideoCount();
      let otherScheduledActivities = 0;
      Object.values(monthDataCache || {}).forEach(rawDayData => {
        const dayArray = Array.isArray(rawDayData) ? rawDayData : (rawDayData ? [rawDayData] : []);
        dayArray.forEach(activity => {
          if (activity.id !== activityId && activity.type === 'ai-shortform') {
            otherScheduledActivities++;
          }
        });
      });
      const newPostActivity = (selectedMarketsList.length > 0) ? 1 : 0;
      const totalFutureActivities = otherScheduledActivities + newPostActivity;
      if (totalFutureActivities > availableCount) {
        showNotification(`âŒ Error: Not enough videos (Available: ${availableCount})`, 'error');
        return;
      }
    }

    // Longform check
    if (type === 'longform') {
        
      let existingLongform = false;
      Object.values(monthDataCache || {}).forEach(rawDayData => {
        const dayArray = Array.isArray(rawDayData) ? rawDayData : (rawDayData ? [rawDayData] : []);
        dayArray.forEach(activity => {
          if (activity.id !== activityId && activity.type === 'longform') {
            existingLongform = true;
          }
        });
      });
      if (existingLongform) {
        showNotification(`âŒ Error: Only one Longform allowed per month.`, 'error');
        return;
      }
    }

    const selectedPlatforms = [];
    if (getCheck('platform-fb')) selectedPlatforms.push('facebook');
    if (getCheck('platform-ig')) selectedPlatforms.push('instagram');
    if (getCheck('platform-tt')) selectedPlatforms.push('tiktok');
    if (getCheck('platform-yt')) selectedPlatforms.push('youtube');
    if (getCheck('platform-gg')) selectedPlatforms.push('google');

// Translation data - collect multiple selected languages
    const enableTranslation = getCheck('enable-translation');
    let selectedLanguages = [];
    if (enableTranslation) {
      document.querySelectorAll('#language-checkboxes input[type="checkbox"]:checked').forEach(cb => {
        selectedLanguages.push(cb.value);
      });
    }

    // Get video translation results
    const videoTranslationResults = {};
    if (videoTranslationState.translationResults && Object.keys(videoTranslationState.translationResults).length > 0) {
      Object.assign(videoTranslationResults, videoTranslationState.translationResults);
    }

    const payload = {
      id: (activityId && !activityId.startsWith('legacy_')) ? activityId : newActivityId(),
      type,
      theme,
      caption,
      captionMode: isManualCaption ? 'manual' : 'ai', // Track caption mode
      platform: selectedPlatforms,
      fileName: manualFileName,
      videoUrl: getVal('edit-video-url') || null,
      markets: selectedMarketsList,
      postTime: postTime,
      translation: {
        enabled: enableTranslation,
        languages: selectedLanguages
      },
      translatedVideos: videoTranslationResults // Changed from videoTranslations to translatedVideos
    };

    if ((type === 'ai-carousel' || type === 'real-carousel') && carouselVideo) {
      payload.carouselVideo = carouselVideo;
    }

    const rawDayData = monthDataCache[day] || null;
    const currentDayArray = (Array.isArray(rawDayData) ? rawDayData : (rawDayData ? [rawDayData] : [])).slice();
    const existingContent = activityId ? currentDayArray.find(item => item.id === activityId) : null;
    
    if (type === 'ai-carousel') {
      payload.aiPrompt = aiPrompt;
      if (existingContent && existingContent.images) {
        payload.images = existingContent.images;
      } else {
        payload.images = [];
      }
    }

    // Trigger the Google Webhook (because 'payload' is now fully defined)
    if (getCheck('platform-gg')) {
        let googleImageUrl = null;
        
        // Logical check for the image: Use AI image first, then fall back to videoUrl if available
        if (type === 'ai-carousel' && payload.images && payload.images.length > 0) {
            const cleanImgName = payload.images[0].replace('carousel-image/', '').replace('carousel-image\\', '');
            googleImageUrl = `${STORAGE_BASE_URL}/${BUCKET_CAROUSEL}/${cleanImgName}`;
        } else if (payload.videoUrl) {
            googleImageUrl = payload.videoUrl;
        }

        // Replace the image_url line in your googlePayload with this:
const googlePayload = {
    date: `${currentDate.getFullYear()}-${z2(currentDate.getMonth() + 1)}-${z2(day)}`,
    summary: caption || theme, 
    // Send the whole array of images instead of just the first one
    images: (type === 'ai-carousel' || type === 'real-carousel') && payload.images 
            ? payload.images.map(img => `${STORAGE_BASE_URL}/${BUCKET_CAROUSEL}/${img.replace('carousel-image/', '').replace('carousel-image\\', '')}`)
            : (payload.videoUrl ? [payload.videoUrl] : []),
    cta_url: "https://aquaversepark.com",
    activity_id: payload.id
};

        console.log("Triggering Google Webhook with:", googlePayload);

        fetch(GOOGLE_BUSINESS_WEBHOOK_URL, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(googlePayload)
        }).then(res => console.log('Google Post automation triggered'))
          .catch(err => console.error('Google automation failed', err));
    }

    if (activityId) {
      const index = currentDayArray.findIndex(item => item.id === activityId);
      if (index > -1) currentDayArray[index] = payload;
      else currentDayArray.push(payload);
    } else {
      currentDayArray.push(payload);
    }

    await writeDay(currentDate, day, currentDayArray);
    showNotification('Content saved successfully!');
    closeModal();

    // Trigger AI Generation (if needed)
    try {
      if (type === 'ai-carousel') {
        const y = currentDate.getFullYear();
        const m = z2(currentDate.getMonth() + 1);
        const d = z2(day);
        const schedule_id = `${y}-${m}-${d}-${payload.id}`;

        const gen = await triggerAICarouselGeneration({
          schedule_id,
          theme,
          prompt: aiPrompt,
          markets: selectedMarketsList,
          platforms: selectedPlatforms,
          count: 6
        });
      
        if (gen.ok) {
            if (gen.data && gen.data.images && gen.data.images.length > 0) {
                 const id = monthId(currentDate);
                 const { data: sel } = await supabase.from('calendars').select('days').eq('id', id).maybeSingle();
                 const days = { ...(sel?.days || {}) };
                 const finalDayArray = (days[day] || []).slice();
                 const indexToUpdate = finalDayArray.findIndex(item => item.id === payload.id);

                 if (indexToUpdate > -1) {
                     finalDayArray[indexToUpdate] = {
                         ...finalDayArray[indexToUpdate],
                         aiGenerated: true,
                         images: gen.data.images.map(p => `${BUCKET_CAROUSEL}${encodeURIComponent(p.replace('carousel-image/', ''))}`)
                     };
                     days[day] = finalDayArray;
                     await supabase.from('calendars').upsert({ id, days }, { onConflict: 'id' });
                     showNotification('AI Assets attached immediately!');
                 }
            } else {
                 waitForAIImages(schedule_id, day, payload.id);
            }
        }
      }
    } catch (err) {
      console.error(err);
      showNotification('Saved, but AI generation check failed.', 'error');
    }
  }

  async function deleteContent() {
    const ok = await ensureAuthenticated();
    if (!ok) return;

    const day = currentlyEditingDay;
    const activityId = document.getElementById('edit-activity-id').value;
    if (!day || !activityId) {
      alert("Error: Could not find item to delete.");
      return;
    }

    const rawDayData = monthDataCache[day] || null;
    const currentDayArray = (Array.isArray(rawDayData) ? rawDayData : (rawDayData ? [rawDayData] : [])).slice();
    const newDayArray = currentDayArray.filter(item => item.id !== activityId);

    await writeDay(currentDate, day, newDayArray);
    showNotification('Content deleted successfully!');
    closeModal();
  }

  function getContentTypeName(type) {
    switch (type) {
      case 'shortform': return 'Shortform';
      case 'ai-shortform': return 'AI Shortform';
      case 'ai-carousel': return 'AI Carousel';
      case 'real-carousel': return 'Real Carousel';
      case 'longform': return 'Longform';
      case 'no-post': return 'No Post';
      default: return '';
    }
  }

  // Function to check post status of each day
  function getPostStatus(dayDataArray, dayNumber) {
    if (!dayDataArray || dayDataArray.length === 0) {
      return 'no-content';
    }

    // Check if it's previous month - if so, consider all posts as posted
    const now = new Date();
    const calendarYear = currentDate.getFullYear();
    const calendarMonth = currentDate.getMonth();
    const currentYear = now.getFullYear();
    const currentMonth = now.getMonth();

    // If calendar shows month before current month, consider all as posted
    if (calendarYear < currentYear || 
        (calendarYear === currentYear && calendarMonth < currentMonth)) {
      return 'all-posted';
    }

    let totalActivities = 0;
    let postedActivities = 0;

    dayDataArray.forEach(activity => {
      if (activity && activity.type && activity.type !== 'no-post') {
        totalActivities++;
        // Check if posted or not - use manual marking as primary method
        if (activity.markedAsPosted === true) {
          postedActivities++;
        }
      }
    });

    if (totalActivities === 0) return 'no-content';
    if (postedActivities === 0) return 'not-posted';
    if (postedActivities === totalActivities) return 'all-posted';
    return 'partial-posted';
  }

  // Helper function to check if scheduled time has passed (including date)
  function isPastTime(postTimeStr, dayNumber) {
    if (!postTimeStr) return false;
    
    const now = new Date();
    const currentYear = currentDate.getFullYear();
    const currentMonth = currentDate.getMonth();
    
    // Create Date object for calendar date
    const calendarDate = new Date(currentYear, currentMonth, dayNumber);
    
    // Convert postTime to Date object
    const [hours, minutes] = postTimeStr.split(':').map(Number);
    const postDateTime = new Date(currentYear, currentMonth, dayNumber, hours, minutes, 0, 0);
    
    // Check if current time has passed the scheduled time
    return now >= postDateTime;
  }

  // Function to create HTML for post status
  function createPostStatusHtml(status) {
    switch (status) {
      case 'all-posted':
        return '<div class="post-status">Posted</div>';
      case 'partial-posted':
        return '<div class="post-status partial-posted">Partial</div>';
      case 'not-posted':
        return '<div class="post-status not-posted">Not Posted</div>';
      default:
        return '';
    }
  }

  function renderCalendar(date) {
    const calendarEl = document.getElementById('calendar');
    const monthYearEl = document.getElementById('current-month');

    const monthNames = ["January","February","March","April","May","June","July","August","September","October","November","December"];
    monthYearEl.textContent = `${monthNames[date.getMonth()]} ${date.getFullYear()}`;

    calendarEl.innerHTML = '';
    const isMobile = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;

    function createActivityHtml(dayData, index = 0) {
     
      if (currentView === 'individual' && selectedMarkets.length > 0) {
        const marketsOnThisActivity = new Set(
          (dayData.markets || []).map(toCanonicalMarket)
        );
        const isMatch = [...selectedMarkets].some(targetMarket =>
          marketsOnThisActivity.has(targetMarket)
        );
        if (!isMatch) return '';
      }

      let viewSpecificHtml = '';
      if (currentView === 'global') {
        const marketCount = (dayData.markets || []).length;
        viewSpecificHtml = `<div class="market-count">${marketCount} market${marketCount !== 1 ? 's' : ''}</div>`;
      } else {
        viewSpecificHtml = `<div class="market-tags">
          ${(dayData.markets || []).map(m => `<span class="market-tag">${toCanonicalMarket(m)}</span>`).join('')}
        </div>`;
      }

      const activityId = dayData.id || `legacy_${index}`;

      let platforms = [];
      if (Array.isArray(dayData.platform)) {
        platforms = dayData.platform;
      } else if (dayData.platform) {
        platforms = [dayData.platform];
      }
      const platformSet = new Set(platforms);

      let platformIcons = '';
      const iconStyle = "font-size: 0.9rem; vertical-align: middle; margin-left: 5px;";
      if (platformSet.has('facebook')) platformIcons += `<i class="fa-brands fa-facebook" style="color:#1877F2; ${iconStyle}"></i>`;
      if (platformSet.has('instagram')) platformIcons += `<i class="fa-brands fa-instagram" style="color:#E4405F; ${iconStyle}"></i>`;
      if (platformSet.has('tiktok')) platformIcons += `<i class="fa-brands fa-tiktok" style="color:#000000; ${iconStyle}"></i>`;
      if (platformSet.has('youtube')) platformIcons += `<i class="fa-brands fa-youtube" style="color:#FF0000; ${iconStyle}"></i>`;

      const videoIndicator = (dayData.carouselVideo) ? ' <i class="fas fa-film" style="font-size:0.7rem; margin-left:3px;"></i>' : '';

      let timeHtml = '';
      if (dayData.postTime) {
        timeHtml = `<span style="font-size:0.75rem; color:#666; background:#eee; padding:1px 4px; border-radius:3px; margin-left:5px;">
                      <i class="far fa-clock"></i> ${dayData.postTime}
                    </span>`;
      }

      return `
        <div class="activity-block" data-activity-id="${activityId}">
          <div class="content-type ${dayData.type}">
             ${getContentTypeName(dayData.type)}${platformIcons}${videoIndicator}
          </div>
          <div style="margin-top:2px;">${timeHtml}</div>
          ${viewSpecificHtml}
          <div class="content-theme">${dayData.theme || ''}</div>
        </div>
      `;
    }

    if (isMobile) {
      // --- MOBILE VIEW ---
      const daysInMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
      const list = document.createElement('div');
      list.className = 'mobile-list';
      calendarEl.appendChild(list);

      for (let d = 1; d <= daysInMonth; d++) {
        const day = document.createElement('div');
        day.className = 'calendar-day' + (isEditMode ? ' editable' : '');
        day.dataset.day = String(d);

        const rawDayData = (monthDataCache && monthDataCache[d]) || null;
        const dayDataArray = Array.isArray(rawDayData) ? rawDayData : (rawDayData ? [rawDayData] : []);

        // Check post status
        const postStatus = getPostStatus(dayDataArray, d);
        const postStatusHtml = createPostStatusHtml(postStatus);

        let activitiesHtml = '';
        dayDataArray.forEach((activityData, index) => {
          activitiesHtml += createActivityHtml(activityData, index);
        });

        let html = `<div class="date-number">${d}`;
        // Add post status next to day number
        html += postStatusHtml;
        if (isEditMode) html += `<span class="edit-indicator"><i class="fas fa-edit"></i></span>`;
        html += `</div>`;
        
        html += activitiesHtml;

        if (activitiesHtml.trim() === '' && currentView === 'global') {
          html += `<div class="empty-day">No content scheduled</div>`;
        } else if (activitiesHtml.trim() === '' && currentView === 'individual' && selectedMarkets.length > 0) {
          html += `<div class="empty-day" style="opacity:0.5;">No content for selected markets</div>`;
        }

        day.innerHTML = html;
        list.appendChild(day);
      }
    } else {
      // --- DESKTOP VIEW ---
      const header = document.createElement('div');
      header.className = 'calendar-header';
      header.innerHTML = `
        <div>Sunday</div><div>Monday</div><div>Tuesday</div>
        <div>Wednesday</div><div>Thursday</div><div>Friday</div><div>Saturday</div>
      `;
      calendarEl.appendChild(header);

      const firstDay = new Date(date.getFullYear(), date.getMonth(), 1).getDay();
      const daysInMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();

      let dayCount = 1;
      for (let i = 0; i < 6; i++) {
        const week = document.createElement('div');
        week.className = 'calendar-week';

        for (let j = 0; j < 7; j++) {
          const day = document.createElement('div');

          if (i === 0 && j < firstDay) {
            const prevMonthDays = new Date(date.getFullYear(), date.getMonth(), 0).getDate();
            const dayNumber = prevMonthDays - firstDay + j + 1;
            day.className = 'calendar-day other-month';
            day.innerHTML = `<div class="date-number">${dayNumber}</div><div>Previous Month</div>`;
          } else if (dayCount > daysInMonth) {
            const dayNumber = dayCount - daysInMonth;
            day.className = 'calendar-day other-month';
            day.innerHTML = `<div class="date-number">${dayNumber}</div><div>Next Month</div>`;
            dayCount++;
          } else {
            const dayClass = isEditMode ? 'calendar-day editable' : 'calendar-day';
            day.className = dayClass;
            day.dataset.day = String(dayCount);

            const rawDayData = (monthDataCache && monthDataCache[dayCount]) || null;
            const dayDataArray = Array.isArray(rawDayData) ? rawDayData : (rawDayData ? [rawDayData] : []);

            // Check post status
            const postStatus = getPostStatus(dayDataArray, dayCount);
            const postStatusHtml = createPostStatusHtml(postStatus);

            let activitiesHtml = '';
            dayDataArray.forEach(activityData => {
            
              activitiesHtml += createActivityHtml(activityData);
            });

            let dayHTML = `<div class="date-number">${dayCount}`;
            // Add post status next to day number
            dayHTML += postStatusHtml;
            if (isEditMode) dayHTML += `<span class="edit-indicator"><i class="fas fa-edit"></i></span>`;
            dayHTML += `</div>`;
            
            dayHTML += activitiesHtml;

            if (activitiesHtml.trim() === '' && currentView === 'global') {
              dayHTML += `<div class="empty-day">No content scheduled</div>`;
            } else if (activitiesHtml.trim() === '' && currentView === 'individual' && selectedMarkets.length > 0) {
              dayHTML += `<div class="empty-day" style="opacity:0.5;">No content</div>`;
            }

            day.innerHTML = dayHTML;
            dayCount++;
          }
          week.appendChild(day);
        }
        calendarEl.appendChild(week);
        if (dayCount > daysInMonth) break;
      }
    }

    updateContentSummary(date);
    updateShortformPerMarketCounts(); 
  }

  function updateContentSummary(date) {
    const monthData = monthDataCache || {};
    let totalPosts = 0, shortformCount = 0, aiShortformCount = 0, aiCount = 0, realCount = 0, longformCount = 0;

    Object.values(monthData).forEach(rawDayData => {
      const dayDataArray = Array.isArray(rawDayData) ? rawDayData : (rawDayData ? [rawDayData] : []);
      dayDataArray.forEach(content => {
        const count = (content.markets || []).length;
        switch (content.type) {
          case 'shortform': shortformCount += count; break;
          case 'ai-shortform': aiShortformCount += count; break;
          case 'ai-carousel': aiCount += count; break;
          case 'real-carousel': realCount += count; break;
          case 'longform': longformCount += count; break;
        }
        if (content.type !== 'no-post') totalPosts += count;
      });
    });

    document.getElementById('total-posts').textContent = String(totalPosts);
    document.getElementById('shortform-count').textContent = String(shortformCount);
    document.getElementById('ai-shortform-count').textContent = String(aiShortformCount);
    document.getElementById('ai-count').textContent = String(aiCount);
    document.getElementById('real-count').textContent = String(realCount);
    document.getElementById('longform-count').textContent = String(longformCount);
  }

  function computeShortformStats() {
    const stats = { total: 0, perMarket: {} };
    ['US','Korea','India','France','Japan','UK','Germany','Thailand'].forEach(m => { stats.perMarket[m] = 0; });

    for (const raw of Object.values(monthDataCache || {})) {
      const dayArr = Array.isArray(raw) ? raw : raw ? [raw] : [];
      dayArr.forEach(item => {
        if (!item || item.type !== 'shortform') return;
        const markets = dedupeMarketsCI((item.markets || []).map(toCanonicalMarket));
        if (markets.length === 0) {
          stats.total += 1;
        } else {
          markets.forEach(m => {
            stats.total += 1;
            if (stats.perMarket[m] != null) {
              stats.perMarket[m] += 1;
            }
          });
        }
      });
    }
    return stats;
  }

  function updateShortformPerMarketCounts() {
    const stats = computeShortformStats();
    const totalEl = document.getElementById('scheduled-shortform-total');
    if (totalEl) {
      totalEl.textContent = `${stats.total} post${stats.total === 1 ? '' : 's'}`;
    }

    const mapIds = {
      US: 'shortform-us-count',
      Korea: 'shortform-korea-count',
      India: 'shortform-india-count',
      France: 'shortform-france-count',
      Japan: 'shortform-japan-count',
      UK: 'shortform-uk-count',
      Germany: 'shortform-germany-count',
      Thailand: 'shortform-thailand-count'
    };

    Object.entries(mapIds).forEach(([market, id]) => {
      const el = document.getElementById(id);
      if (!el) return;
      const n = stats.perMarket[market] || 0;
      el.textContent = `${n}`;
    });
  }

  // Cache for video count to reduce API calls
  let videoCountCache = {
    count: null,
    timestamp: null,
    cacheDuration: 600000 // Cache for 10 minutes
  };

  let updateFolderCountsDebounce = null;

  async function updateFolderCounts() {
    const month = currentDate.getMonth();
    if (month === 10) {
      document.getElementById('ready-count').textContent = '112 items';
      document.getElementById('posted-count').textContent = '0 items';
    } else {
      document.getElementById('ready-count').textContent = '0 items';
      document.getElementById('posted-count').textContent = '0 items';
    }

    const count = await getRealtimeVideoCount();
    updateAvailableVideoCountUI(count);
    updateShortformPerMarketCounts();
  }

  async function getRealtimeVideoCount() {
    // Check cache first
    const now = Date.now();
    if (videoCountCache.count !== null && 
        videoCountCache.timestamp && 
        (now - videoCountCache.timestamp) < videoCountCache.cacheDuration) {
      console.log(`Using cached video count: ${videoCountCache.count} (cached ${Math.round((now - videoCountCache.timestamp) / 1000)}s ago)`);
      return videoCountCache.count;
    }

    console.log("Fetching real-time inventory from Storage...");
    const { data: videos, error } = await supabase
      .storage
      .from('ShortVideo')
      .list('', { limit: 2000 });

    if (error) {
      console.error('Error fetching storage list:', error);
      showNotification('âŒ Error: Could not read Storage list (RLS?)', 'error');
      return videoCountCache.count || 0; // Return cached value if available
    }

    const videoFiles = (videos || []).filter(file => {
      const name = file.name ? file.name.toLowerCase() : '';
      return name !== '.emptyfolderplaceholder';
    });

    const count = videoFiles.length;
    console.log(`Real-time count is: ${count}`);
    
    // Update cache
    videoCountCache.count = count;
    videoCountCache.timestamp = now;
    
    return count;
  }

  function updateAvailableVideoCountUI(count) {
    const countEl = document.getElementById('available-video-count');
    if (!countEl) return;

    if (count === 'N/A' || count === undefined) {
      countEl.textContent = 'N/A';
      return;
    }

    countEl.textContent = `${count} items`;
    if (count < 5) {
      countEl.style.background = 'var(--secondary)';
    } else {
      countEl.style.background = 'var(--primary)';
    }
  }

  async function getUsedFilenames(currentActivityId) {
    const used = new Set();
    
    try {
      // Get all months from the database to check ALL scheduled content
      const { data: allMonths, error } = await supabase
        .from(table)
        .select('id, days');

      if (error) {
        console.error('Error fetching all months for filtering:', error);
        // Fallback to current month only if database query fails
        Object.values(monthDataCache || {}).forEach(dayData => {
          const activities = Array.isArray(dayData) ? dayData : (dayData ? [dayData] : []);
          activities.forEach(act => {
            if (act.id === currentActivityId) return;
            if (act.fileName) used.add(act.fileName);
            if (act.carouselVideo) used.add(act.carouselVideo);
          });
        });
        return used;
      }

      // Check all months for used filenames
      (allMonths || []).forEach(monthData => {
        const days = monthData.days || {};
        Object.values(days).forEach(dayData => {
          const activities = Array.isArray(dayData) ? dayData : (dayData ? [dayData] : []);
          
          activities.forEach(act => {
            if (act.id === currentActivityId) return;

            if (act.fileName) {
              used.add(act.fileName);
            }

            if (act.carouselVideo) {
              used.add(act.carouselVideo);
            }
          });
        });
      });
      
    } catch (err) {
      console.error('Error in getUsedFilenames:', err);
      // Fallback to current month only
      Object.values(monthDataCache || {}).forEach(dayData => {
        const activities = Array.isArray(dayData) ? dayData : (dayData ? [dayData] : []);
        activities.forEach(act => {
          if (act.id === currentActivityId) return;
          if (act.fileName) used.add(act.fileName);
          if (act.carouselVideo) used.add(act.carouselVideo);
        });
      });
    }
    
    return used;
  }

  async function openVideoPicker() {
    const modal = document.getElementById('video-picker-modal');
    const container = document.getElementById('video-list-container');
    const searchInput = document.getElementById('video-search');
    
    searchInput.value = ''; 
    modal.style.display = 'flex';
    container.innerHTML = '<div style="text-align:center; margin-top:20px;"><i class="fas fa-spinner fa-spin"></i> Loading Library...</div>';

    try {
      const type = document.getElementById('content-type').value;
      const currentActivityId = document.getElementById('edit-activity-id').value;
      let allFiles = [];
      if (type === 'shortform' || type === 'longform') {
        // Use Canto for Shortform and Longform
        const folder = CANTO_FOLDER_MAP[type];
        allFiles = await fetchCantoVideos(folder);
      } else {
        // Use Supabase as before
        let bucket = "ShortForm"; 
        if (type === 'ai-shortform') {
            bucket = "ShortVideo"; 
        }
        const res = await fetch(`${LIST_VIDEOS_WEBHOOK_URL}?bucket=${bucket}`);
        if (!res.ok) throw new Error(`API Error: ${res.status}`);
        const responseText = await res.text();
        if (responseText.trim()) {
          try {
            allFiles = JSON.parse(responseText);
          } catch (jsonError) {
            console.error('JSON parse error:', jsonError);
            throw new Error('Invalid JSON response from server');
          }
        } else {
          allFiles = [];
        }
      }

      const usedFilenames = await getUsedFilenames(currentActivityId);
      const availableFiles = allFiles.filter(file => !usedFilenames.has(file.name));

      renderVideoList(availableFiles);

      searchInput.onkeyup = (e) => {
        const term = e.target.value.toLowerCase();
        const filtered = availableFiles.filter(f => f.name.toLowerCase().includes(term));
        renderVideoList(filtered);
      };

    } catch (err) {
      container.innerHTML = `<div style="color:red; text-align:center;">Error loading videos.<br>${err.message}</div>`;
      console.error(err);
    }
}

  function renderVideoList(files) {
    const container = document.getElementById('video-list-container');
    container.innerHTML = '';

    if(!files || files.length === 0) {
        container.innerHTML = '<div style="text-align:center; padding:20px; color:#999;">No videos found.</div>';
        return;
    }

    files.forEach(file => {
      if(file.name === '.emptyFolderPlaceholder') return;
   
      const sizeBytes = file.size || (file.metadata && file.metadata.size) || 0;
      const sizeMB = (sizeBytes / 1024 / 1024).toFixed(2);

      const div = document.createElement('div');
      div.style.cssText = "padding:12px; border-bottom:1px solid #eee; cursor:pointer; display:flex; justify-content:space-between; align-items:center; transition:background 0.2s;";
      div.onmouseover = () => div.style.background = "#f8f9fa";
      div.onmouseout = () => div.style.background = "white";

      div.innerHTML = `
        <div style="pointer-events:none;">
            <i class="fas fa-file-video" style="color:#666; margin-right:10px;"></i>
            <strong>${file.name}</strong>
            <div style="font-size:0.8rem; color:#999; margin-left:26px; margin-top:2px;">Size: ${sizeMB} MB</div>
        </div>
        <button class="btn btn-secondary" style="padding:4px 12px; font-size:0.8rem; pointer-events:none;">Select</button>
      `;
   
      div.onclick = () => selectVideo(file);
      
      container.appendChild(div);
    });
  }

  function selectVideo(file) {
    // Clear any loading indicators in the video picker modal
    const pickerContainer = document.getElementById('video-list-container');
    
    
    document.getElementById('selected-filename').value = file.name;
    document.getElementById('edit-video-url').value = file.directUrlOriginal || file.directUrl || file.url || '';
    
    const previewBox = document.getElementById('preview-container');
    const player = document.getElementById('video-player-preview');
    const errorMsg = document.getElementById('video-error-message');
    const loadingIndicator = document.getElementById('video-loading-indicator');
 
    // Reset video element
    player.style.display = 'block';
    if (errorMsg) errorMsg.style.display = 'none';
    if (loadingIndicator) loadingIndicator.style.display = 'block';
    player.pause();
    player.currentTime = 0;
    player.src = '';
    
    // Use directUrlOriginal/directUrl/url for preview if available (Canto), otherwise construct it (Supabase)
    const fullUrl = file.directUrlOriginal || file.directUrl || file.url || getFileUrl(file.name, document.getElementById('content-type').value);
    console.log(`Selecting video: ${file.name}`, { 
      directUrlOriginal: file.directUrlOriginal,
      directUrl: file.directUrl,
      url: file.url, 
      finalUrl: fullUrl 
    });
    
    // Set new source and show preview
    player.src = fullUrl;
    previewBox.style.display = 'block';
    
    // Close the video picker modal immediately after selection
    document.getElementById('video-picker-modal').style.display = 'none';
    
    // Update video translation source if video translation is enabled
    if (typeof updateVideoTranslationSource === 'function') {
      updateVideoTranslationSource();
    }
    
    // Handle loading
    player.onloadedmetadata = () => {
      console.log('Video loaded successfully:', fullUrl);
      if (loadingIndicator) loadingIndicator.style.display = 'none';
    };
    
    player.onerror = () => {
      console.error('Video failed to load:', fullUrl);
      player.style.display = 'none';
      if (loadingIndicator) loadingIndicator.style.display = 'none';
      if (errorMsg) errorMsg.style.display = 'block';
    };
  }

  // Add the missing functions for video picker
  document.getElementById('open-picker-btn').addEventListener('click', openVideoPicker);
  document.getElementById('close-picker').addEventListener('click', () => document.getElementById('video-picker-modal').style.display = 'none');
  document.getElementById('cancel-picker').addEventListener('click', () => document.getElementById('video-picker-modal').style.display = 'none');
  
  document.getElementById('clear-video-btn').addEventListener('click', () => {
    document.getElementById('selected-filename').value = '';
    document.getElementById('edit-video-url').value = '';
    const player = document.getElementById('video-player-preview');
    const errorMsg = document.getElementById('video-error-message');
    const loadingIndicator = document.getElementById('video-loading-indicator');
    player.pause();
    player.currentTime = 0;
    player.src = '';
    player.style.display = 'block';
    if (errorMsg) errorMsg.style.display = 'none';
    if (loadingIndicator) loadingIndicator.style.display = 'none';
    document.getElementById('preview-container').style.display = 'none';
    
    // Update video translation source when video is cleared
    if (typeof updateVideoTranslationSource === 'function') {
      updateVideoTranslationSource();
    }
  });

  // Caption mode toggle functionality
  function toggleCaptionField() {
    const captionTextarea = document.getElementById('content-caption');
    const isManual = document.getElementById('caption-manual').checked;
    if (captionTextarea) {
      captionTextarea.style.display = isManual ? 'block' : 'none';
      if (!isManual) {
        captionTextarea.value = ''; // Clear when switching to AI
      }
    }
  }

  // Add event listeners for caption mode radio buttons
  document.getElementById('caption-manual').addEventListener('change', toggleCaptionField);
  document.getElementById('caption-ai').addEventListener('change', toggleCaptionField);

  // Translation feature functionality (Old text translation - now replaced by video translation)
  // Keeping this for backward compatibility but checking if element exists
  function toggleTranslationSection() {
    const translationCheckbox = document.getElementById('enable-translation');
    const translationSection = document.getElementById('translation-language-section');
    
    // Only run if elements exist (backward compatibility)
    if (!translationCheckbox || !translationSection) return;
    
    if (translationCheckbox.checked) {
      translationSection.style.display = 'block';
    } else {
      translationSection.style.display = 'none';
      // Reset language selections when unchecked
      const checkboxes = document.querySelectorAll('#language-checkboxes input[type="checkbox"]');
      if (checkboxes) {
        checkboxes.forEach(cb => {
          cb.checked = false;
        });
      }
    }
  }

  // Select all languages functionality
  function updateSelectAllLanguagesButton() {
    const languageCheckboxes = document.querySelectorAll('#language-checkboxes input[type="checkbox"]');
    const checkedLanguages = document.querySelectorAll('#language-checkboxes input[type="checkbox"]:checked');
    const allChecked = languageCheckboxes.length > 0 && checkedLanguages.length === languageCheckboxes.length;
    const button = document.getElementById('select-all-languages');
    if (button) {
      button.textContent = allChecked ? 'Deselect All' : 'Select All';
    }
  }

  // Add event listeners for translation functionality (only if element exists)
  const enableTranslationCheckbox = document.getElementById('enable-translation');
  if (enableTranslationCheckbox) {
    enableTranslationCheckbox.addEventListener('change', toggleTranslationSection);
  }
  
  // Select All Languages button functionality
  document.addEventListener('click', function(e) {
    if (e.target.id === 'select-all-languages') {
      const languageCheckboxes = document.querySelectorAll('#language-checkboxes input[type="checkbox"]');
      const checkedLanguages = document.querySelectorAll('#language-checkboxes input[type="checkbox"]:checked');
      const allChecked = languageCheckboxes.length > 0 && checkedLanguages.length === languageCheckboxes.length;
      
      languageCheckboxes.forEach(cb => {
        cb.checked = !allChecked;
      });
      
      updateSelectAllLanguagesButton();
    }
  });

  // Update select all button when individual language checkboxes change
  document.addEventListener('change', function(e) {
    if (e.target.closest('#language-checkboxes')) {
      updateSelectAllLanguagesButton();
    }
  });

  // Add the missing waitForAIImages function
  async function waitForAIImages(scheduleId, day, payloadId) {
    let attempts = 0;
    const maxAttempts = 90;
    const interval = 10000;

    console.log(`ðŸ” Start Polling. Looking for ID part: "${payloadId}"`);
    showNotification('AI processing... Waiting for images.', 'success');

    const poll = setInterval(async () => {
      attempts++;
      console.log(`Attempt ${attempts}: Reading storage...`);

      const { data: files, error } = await supabase
        .storage
        .from(BUCKET_CAROUSEL)
        .list('', { limit: 100, sortBy: { column: 'created_at', order: 'desc' } });
        console.log("ðŸ“‚ Files found in bucket:", files);

      if (error) { 
          console.error("âŒ Polling Error (Check Storage Policies):", error); 
          return; 
      }

      const matchedFiles = files.filter(f => f.name.includes(payloadId));

      if (matchedFiles.length > 0) {
        clearInterval(poll);
        
        const imageFilenames = matchedFiles.map(f => f.name);
        console.log("âœ… Found Match!", imageFilenames);

        const id = monthId(currentDate);
        const { data: sel } = await supabase.from('calendars').select('days').eq('id', id).maybeSingle();
        
        if (sel && sel.days) {
            const days = { ...sel.days };
            const currentDayArr = days[day] || [];
            const indexToUpdate = currentDayArr.findIndex(item => item.id === payloadId);

            if (indexToUpdate > -1) {
                currentDayArr[indexToUpdate] = {
                    ...currentDayArr[indexToUpdate],
                    aiGenerated: true,
                    images: imageFilenames 
                };
                days[day] = currentDayArr;

                await supabase.from('calendars').upsert({ id, days }, { onConflict: 'id' });
                
                monthDataCache = days;
               
                showNotification(`Success! AI generated ${matchedFiles.length} images.`);
              
            }
        }
      } 
      
      if (attempts >= maxAttempts) {
        clearInterval(poll);
        showNotification('Timeout: Images not found. Please check manually.', 'error');
      }

    }, interval);
  }

  // Add the missing switchView function
  window.switchView = function(view) {
    document.querySelectorAll('.nav-tab').forEach(tab => {
      tab.classList.remove('active');
    });
    
    if(view === 'calendar') {
      document.querySelector('.nav-tab:first-child').classList.add('active');
      document.getElementById('calendar-view').style.display = 'block';
      document.getElementById('analytics-view').style.display = 'none';
    } else {
      document.querySelector('.nav-tab:last-child').classList.add('active');
      document.getElementById('calendar-view').style.display = 'none';
      document.getElementById('analytics-view').style.display = 'block';
    }
  };

  // ==================== VIDEO TRANSLATION FEATURE ====================
  
  // Configuration - âš ï¸ IMPORTANT: Replace with your actual n8n webhook URL
  const VIDEO_TRANSLATION_CONFIG = {
    webhookUrl: 'https://saschag.app.n8n.cloud/webhook/VIDEO_TRANSLATION_CONFIG',
    pollInterval: 5000, // 5 seconds
    maxPollAttempts: 360, // 30 minutes max
  };

  // State management
  let videoTranslationState = {
    selectedVideoUrl: null,
    selectedVideoFilename: null,
    selectedLanguages: new Set(),
    translationResults: {},
    pollingIntervals: {}
  };

  // Initialize video translation feature
  function initVideoTranslation() {
    // Enable/disable video translation section
    const enableVideoTranslation = document.getElementById('enable-video-translation');
    const videoTranslationSection = document.getElementById('video-translation-section');
    
    if (enableVideoTranslation) {
      enableVideoTranslation.addEventListener('change', function() {
        if (this.checked) {
          videoTranslationSection.style.display = 'block';
          updateVideoTranslationSource();
        } else {
          videoTranslationSection.style.display = 'none';
          resetVideoTranslation();
        }
      });
    }

    // Language selection
    const languageCheckboxes = document.querySelectorAll('#translation-language-checkboxes input[type="checkbox"]');
    languageCheckboxes.forEach(checkbox => {
      checkbox.addEventListener('change', (e) => {
        if (e.target.checked) {
          videoTranslationState.selectedLanguages.add(e.target.value);
        } else {
          videoTranslationState.selectedLanguages.delete(e.target.value);
        }
        updateStartTranslationButton();
      });
    });

    // Select all languages
    const selectAllBtn = document.getElementById('select-all-translation-languages');
    if (selectAllBtn) {
      selectAllBtn.addEventListener('click', () => {
        const checkboxes = document.querySelectorAll('#translation-language-checkboxes input[type="checkbox"]');
        const allChecked = Array.from(checkboxes).every(cb => cb.checked);
        
        checkboxes.forEach(cb => {
          cb.checked = !allChecked;
          if (cb.checked) {
            videoTranslationState.selectedLanguages.add(cb.value);
          } else {
            videoTranslationState.selectedLanguages.delete(cb.value);
          }
        });
        
        selectAllBtn.textContent = allChecked ? 'Select All' : 'Deselect All';
        updateStartTranslationButton();
      });
    }

    // Email input
    const emailInput = document.getElementById('video-translation-email');
    if (emailInput) {
      emailInput.addEventListener('input', updateStartTranslationButton);
    }

    // Start translation button
    const startBtn = document.getElementById('start-video-translation');
    if (startBtn) {
      startBtn.addEventListener('click', handleStartVideoTranslation);
    }
  }

  // Update video translation source from Selected Video
  function updateVideoTranslationSource() {
    const videoUrl = document.getElementById('edit-video-url')?.value;
    const videoFilename = document.getElementById('selected-filename')?.value;
    const sourceInfo = document.getElementById('video-translation-source-info');
    const sourceName = document.getElementById('video-translation-source-name');
    const noVideoWarning = document.getElementById('video-translation-no-video-warning');

    if (videoUrl && videoFilename) {
      videoTranslationState.selectedVideoUrl = videoUrl;
      videoTranslationState.selectedVideoFilename = videoFilename;
      
      if (sourceInfo && sourceName) {
        sourceName.textContent = videoFilename;
        sourceInfo.style.display = 'block';
      }
      if (noVideoWarning) {
        noVideoWarning.style.display = 'none';
      }
    } else {
      videoTranslationState.selectedVideoUrl = null;
      videoTranslationState.selectedVideoFilename = null;
      
      if (sourceInfo) {
        sourceInfo.style.display = 'none';
      }
      if (noVideoWarning) {
        noVideoWarning.style.display = 'block';
      }
    }
    
    updateStartTranslationButton();
  }

  function updateStartTranslationButton() {
    const startBtn = document.getElementById('start-video-translation');
    const emailInput = document.getElementById('video-translation-email');
    
    if (startBtn && emailInput) {
      const hasVideo = videoTranslationState.selectedVideoUrl !== null;
      const hasLanguages = videoTranslationState.selectedLanguages.size > 0;
      // Email is now optional, so we don't check it

      startBtn.disabled = !(hasVideo && hasLanguages);
    }
  }

  async function handleStartVideoTranslation() {
    const emailInput = document.getElementById('video-translation-email');
    if (!videoTranslationState.selectedVideoUrl || videoTranslationState.selectedLanguages.size === 0) {
      alert('Please select a video in the "Selected Video" section first.');
      return;
    }

    const startBtn = document.getElementById('start-video-translation');
    if (startBtn) {
      startBtn.disabled = true;
      startBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Checking...';
    }

    try {
      // 1. Check if translated videos already exist in Canto for each selected language
      const cantoFiles = await fetchCantoVideos('videotranslation');
      const originalFilename = videoTranslationState.selectedVideoFilename || '';
      const baseFilename = originalFilename.replace(/\.[^/.]+$/, '');
      const missingLanguages = [];
      const foundLanguages = [];
      const foundFiles = {};

      videoTranslationState.selectedLanguages.forEach(lang => {
        // Try to find a file for this language
        const matchedFile = cantoFiles.find(file => {
          const filename = file.name;
          const filenameLower = filename.toLowerCase();
          const langLower = lang.toLowerCase();
          // Pattern: BaseFilename_Language.ext
          if (filename.startsWith(baseFilename + '_')) {
            const afterUnderscore = filename.substring(baseFilename.length + 1);
            const langPart = afterUnderscore.split('.')[0];
            if (langPart.toLowerCase() === langLower) return true;
          }
          // Pattern: Contains both base filename and language
          const baseFilenameLower = baseFilename.toLowerCase();
          if (filenameLower.includes(baseFilenameLower) && filenameLower.includes(`_${langLower}`)) {
            return true;
          }
          // Pattern: Try with language code
          const langCode = getLangCode(lang);
          if (filename.startsWith(baseFilename + '_')) {
            const afterUnderscore = filename.substring(baseFilename.length + 1);
            const langPart = afterUnderscore.split('.')[0];
            if (langPart.toLowerCase() === langCode.toLowerCase()) return true;
          }
          return false;
        });
        if (matchedFile) {
          foundLanguages.push(lang);
          foundFiles[lang] = matchedFile;
        } else {
          missingLanguages.push(lang);
        }
      });

      // 2. Show progress section and initialize progress for all
      showVideoTranslationProgress();
      initializeVideoTranslationProgress();

      // 3. For found languages, show result immediately
      foundLanguages.forEach(lang => {
        updateVideoTranslationProgress(lang, 'success');
        // Pass the full file object so addVideoTranslationResult can extract the URL properly
        addVideoTranslationResult(lang, foundFiles[lang]);
      });

      // 4. If all found, skip webhook
      if (missingLanguages.length === 0) {
        showNotification('All selected translations already exist!', 'success');
        if (startBtn) {
          startBtn.disabled = false;
          startBtn.innerHTML = '<i class="fas fa-language"></i> Start Translation';
        }
        return;
      }

      // 5. If some missing, send only those to webhook
      // Download video from URL first
      const videoBlob = await fetch(videoTranslationState.selectedVideoUrl).then(r => r.blob());
      // Create FormData
      const formData = new FormData();
      formData.append('file', videoBlob, videoTranslationState.selectedVideoFilename);
      formData.append('filename', videoTranslationState.selectedVideoFilename);
      formData.append('language', missingLanguages.join(', '));
      formData.append('e-mail', emailInput ? emailInput.value.trim() : '');

      // Send to n8n webhook
      const response = await fetch(VIDEO_TRANSLATION_CONFIG.webhookUrl, {
        method: 'POST',
        body: formData
      });

      if (!response.ok) {
        throw new Error('Failed to send data to webhook');
      }

      const result = await response.json();
      console.log('Video translation webhook response:', result);

      // Start polling for missing languages only
      videoTranslationState.selectedLanguages = new Set(missingLanguages);
      startVideoTranslationPolling();

      showNotification('Video translation started for missing languages!', 'success');

    } catch (error) {
      console.error('Error starting video translation:', error);
      alert('An error occurred while submitting data. Please try again.');
      if (startBtn) {
        startBtn.disabled = false;
        startBtn.innerHTML = '<i class="fas fa-language"></i> Start Translation';
      }
    }
  }

  function showVideoTranslationProgress() {
    const progressSection = document.getElementById('video-translation-progress');
    if (progressSection) {
      progressSection.style.display = 'block';
    }
  }

  function initializeVideoTranslationProgress() {
    const container = document.getElementById('video-translation-progress-container');
    if (!container) return;

    container.innerHTML = '';

    videoTranslationState.selectedLanguages.forEach(lang => {
      const progressItem = document.createElement('div');
      progressItem.className = 'translation-progress-item';
      progressItem.id = `translation-progress-${lang}`;
      progressItem.innerHTML = `
        <div class="translation-progress-header">
          <div class="translation-progress-lang">${getLangFlag(lang)} ${lang}</div>
          <div class="translation-status-badge translation-status-processing">
            <i class="fas fa-spinner fa-spin"></i> Processing
          </div>
        </div>
        <div class="translation-progress-bar">
          <div class="translation-progress-bar-fill" style="width: 30%"></div>
        </div>
      `;
      container.appendChild(progressItem);
    });
  }

  function startVideoTranslationPolling() {
    // Poll Canto folder KJGAJ for translated videos
    const POLLING_INTERVAL = 10000; // 10 seconds
    const MAX_ATTEMPTS = 180; // 30 minutes max (180 * 10s)
    
    console.log('ðŸ” Starting to poll Canto folder KJGAJ for translated videos...');
    console.log('ðŸ“ Looking for languages:', Array.from(videoTranslationState.selectedLanguages));
    console.log('ðŸ“„ Original filename:', videoTranslationState.selectedVideoFilename);
    
    // Track polling state for each language
    const pollingState = {};
    videoTranslationState.selectedLanguages.forEach(lang => {
      pollingState[lang] = {
        attempts: 0,
        found: false
      };
    });

    const pollInterval = setInterval(async () => {
      try {
        // Fetch files from Canto folder KJGAJ
        const cantoFiles = await fetchCantoVideos('KJGAJ');
        console.log(`ðŸ“‚ Polling attempt - Found ${cantoFiles.length} files in KJGAJ`);
        
        // Debug: Log all filenames found
        if (cantoFiles.length > 0) {
          console.log('ðŸ“‹ Files in folder:', cantoFiles.map(f => f.name).join(', '));
        }
        
        // Get base filename without extension
        const originalFilename = videoTranslationState.selectedVideoFilename || '';
        const baseFilename = originalFilename.replace(/\.[^/.]+$/, ''); // Remove extension
        
        console.log('ðŸ”Ž Base filename for matching:', baseFilename);
        
        // Check each language
        for (const lang of videoTranslationState.selectedLanguages) {
          if (pollingState[lang].found) continue; // Skip if already found
          
          pollingState[lang].attempts++;
          
          // Look for file matching the language
          // Expected pattern: {BaseFilename}_{Language}.mp4 (e.g., "A New Day_English.mp4")
          const matchedFile = cantoFiles.find(file => {
            const filename = file.name;
            const filenameLower = filename.toLowerCase();
            const langLower = lang.toLowerCase();
            
            console.log(`ðŸ” Checking "${filename}" for language "${lang}"`);
            
            // Pattern 1: Exact match - BaseFilename_Language.ext
            // Example: "A New Day_English.mp4" matches language "English"
            if (filename.startsWith(baseFilename + '_')) {
              const afterUnderscore = filename.substring(baseFilename.length + 1);
              const langPart = afterUnderscore.split('.')[0]; // Get part before extension
              
              console.log(`  â†’ Pattern 1 check: "${langPart}" vs "${lang}"`);
              
              if (langPart.toLowerCase() === langLower) {
                console.log(`  âœ… MATCH! Pattern 1`);
                return true;
              }
            }
            
            // Pattern 2: Contains both base filename and language
            const baseFilenameLower = baseFilename.toLowerCase();
            if (filenameLower.includes(baseFilenameLower) && filenameLower.includes(`_${langLower}`)) {
              console.log(`  âœ… MATCH! Pattern 2`);
              return true;
            }
            
            // Pattern 3: Try with language code
            const langCode = getLangCode(lang);
            if (filename.startsWith(baseFilename + '_')) {
              const afterUnderscore = filename.substring(baseFilename.length + 1);
              const langPart = afterUnderscore.split('.')[0];
              
              if (langPart.toLowerCase() === langCode.toLowerCase()) {
                console.log(`  âœ… MATCH! Pattern 3 (code: ${langCode})`);
                return true;
              }
            }
            
            return false;
          });
          
          if (matchedFile) {
            console.log(`âœ… Found translated video for ${lang}:`, matchedFile.name);
            pollingState[lang].found = true;
            
            // Update progress to success
            updateVideoTranslationProgress(lang, 'success');
            
            // Pass the full file object so addVideoTranslationResult can extract the URL properly
            addVideoTranslationResult(lang, matchedFile);
          } else {
            console.log(`â³ ${lang}: Not found yet (attempt ${pollingState[lang].attempts}/${MAX_ATTEMPTS})`);
            
            // Update progress bar
            const progressPercent = Math.min(30 + (pollingState[lang].attempts / MAX_ATTEMPTS * 60), 90);
            const progressItem = document.getElementById(`translation-progress-${lang}`);
            if (progressItem) {
              const progressBar = progressItem.querySelector('.translation-progress-bar-fill');
              if (progressBar) progressBar.style.width = `${progressPercent}%`;
            }
          }
          
          // Check if max attempts reached
          if (pollingState[lang].attempts >= MAX_ATTEMPTS && !pollingState[lang].found) {
            console.error(`âŒ Timeout: ${lang} video not found after ${MAX_ATTEMPTS} attempts`);
            updateVideoTranslationProgress(lang, 'error');
          }
        }
        
        // Check if all languages are done (found or timed out)
        const allDone = Array.from(videoTranslationState.selectedLanguages).every(lang => 
          pollingState[lang].found || pollingState[lang].attempts >= MAX_ATTEMPTS
        );
        
        if (allDone) {
          console.log('âœ… All translations completed or timed out. Stopping polling.');
          clearInterval(pollInterval);
          
          const foundCount = Array.from(videoTranslationState.selectedLanguages).filter(lang => pollingState[lang].found).length;
          const totalCount = videoTranslationState.selectedLanguages.size;
          
          showNotification(`Translation complete: ${foundCount}/${totalCount} videos found`, foundCount === totalCount ? 'success' : 'error');
        }
        
      } catch (error) {
        console.error('Error polling Canto folder:', error);
      }
    }, POLLING_INTERVAL);
    
    // Store interval for cleanup
    videoTranslationState.pollingIntervals.main = pollInterval;
  }

  // Helper function to get language code
  function getLangCode(language) {
    const langCodes = {
      'English': 'en',
      'Japanese': 'ja',
      'Tamil': 'ta',
      'Chinese': 'zh',
      'Korean': 'ko',
      'Hindi': 'hi',
      'Arabic': 'ar',
      'Bengali': 'bn',
      'Russian': 'ru',
      'Marathi': 'mr',
      'French': 'fr',
      'German': 'de',
      'Portuguese': 'pt'
    };
    return langCodes[language] || language.substring(0, 2).toLowerCase();
  }

  function updateVideoTranslationProgress(language, status) {
    const progressItem = document.getElementById(`translation-progress-${language}`);
    if (!progressItem) return;

    const statusBadge = progressItem.querySelector('.translation-status-badge');
    const progressBar = progressItem.querySelector('.translation-progress-bar-fill');

    if (status === 'success') {
      statusBadge.className = 'translation-status-badge translation-status-success';
      statusBadge.innerHTML = '<i class="fas fa-check-circle"></i> Complete';
      if (progressBar) progressBar.style.width = '100%';
    } else if (status === 'error') {
      statusBadge.className = 'translation-status-badge translation-status-error';
      statusBadge.innerHTML = '<i class="fas fa-exclamation-circle"></i> Error';
      if (progressBar) {
        progressBar.style.width = '100%';
        progressBar.style.background = '#dc3545';
      }
    }
  }

  // Helper function to add a translation result card to the UI
  function addVideoTranslationResultCard(language, videoUrl) {
    const resultsSection = document.getElementById('video-translation-results');
    const resultsGrid = document.getElementById('video-translation-results-grid');
    
    if (resultsSection && resultsGrid) {
      resultsSection.style.display = 'block';

      // Remove existing card if present
      const existingCard = document.getElementById(`translation-result-${language}`);
      if (existingCard) existingCard.remove();

      // Get current markets from main form
      const currentMarkets = Array.from(document.querySelectorAll('#market-checkboxes input[type="checkbox"]:checked'))
        .map(cb => cb.value);
      
      // Generate market checkboxes for this language
      const marketCheckboxesHtml = MARKETS.map(market => {
        const isChecked = currentMarkets.includes(market) ? 'checked' : '';
        return `
          <label style="display: inline-flex; align-items: center; gap: 4px; margin: 4px 8px 4px 0; font-size: 0.85rem; cursor: pointer;">
            <input type="checkbox" value="${market}" ${isChecked} 
                   onchange="updateTranslatedVideoMarkets('${language}')" 
                   style="cursor: pointer;">
            <span>${market}</span>
          </label>
        `;
      }).join('');

      // Create result card
      const resultCard = document.createElement('div');
      resultCard.className = 'translation-result-card';
      resultCard.id = `translation-result-${language}`;
      resultCard.innerHTML = `
        <div class="translation-result-header">
          ${getLangFlag(language)} ${language}
        </div>
        <div class="translation-result-body">
          <video class="translation-result-video" controls src="${videoUrl}"></video>
          
          <div style="margin: 12px 0; padding: 10px; background: #f8f9fa; border-radius: 6px;">
            <label style="font-weight: 600; font-size: 0.9rem; color: #495057; display: block; margin-bottom: 8px;">
              <i class="fas fa-globe"></i> Target Markets
            </label>
            <div id="markets-${language}" style="display: flex; flex-wrap: wrap;">
              ${marketCheckboxesHtml}
            </div>
          </div>
          
          <div class="translation-result-actions">
            <button class="translation-result-btn translation-regenerate-btn" onclick="regenerateVideoTranslation('${language}')">
              <i class="fas fa-redo"></i> Regenerate
            </button>
            <button class="translation-result-btn translation-download-btn" onclick="downloadVideoTranslation('${videoUrl}', '${language}')">
              <i class="fas fa-download"></i> Download
            </button>
            <button class="translation-result-btn translation-delete-btn" onclick="deleteVideoTranslation('${language}')" style="background: #dc3545;">
              <i class="fas fa-trash"></i> Delete
            </button>
          </div>
        </div>
      `;

      resultsGrid.appendChild(resultCard);
    }
  }

  function addVideoTranslationResult(language, videoUrl) {
    // Accept file object or string
    let finalUrl = '';
    let fileObj = null;
    let fileName = '';
    if (videoUrl && typeof videoUrl === 'object') {
      fileObj = videoUrl;
      finalUrl = fileObj.directUrlOriginal || fileObj.directUrl || fileObj.url || '';
      fileName = fileObj.name || '';
      console.log(`[addVideoTranslationResult] File object for ${language}:`, fileObj);
      console.log(`[addVideoTranslationResult] Using finalUrl:`, finalUrl);
    } else if (typeof videoUrl === 'string') {
      finalUrl = videoUrl;
      console.log(`[addVideoTranslationResult] String URL for ${language}:`, finalUrl);
    }
    // Fallback: try other known keys if still missing
    if (!finalUrl && fileObj) {
      finalUrl = fileObj['directUrl'] || fileObj['url'] || '';
      console.log(`[addVideoTranslationResult] Fallback finalUrl:`, finalUrl);
    }
    if (!finalUrl) {
      console.warn('No video URL found for language', language, videoUrl);
      return;
    }

    // Get default markets from main form
    const defaultMarkets = Array.from(document.querySelectorAll('#market-checkboxes input[type="checkbox"]:checked'))
      .map(cb => cb.value);

    // Save to state (including filename and markets)
    videoTranslationState.translationResults[language] = {
      url: finalUrl,
      filename: fileName,
      markets: defaultMarkets.length > 0 ? defaultMarkets : MARKETS // Default to all markets if none selected
    };

    // Add card to UI
    addVideoTranslationResultCard(language, finalUrl);
  }

  // Function to update markets for a translated video
  window.updateTranslatedVideoMarkets = function(language) {
    const marketsContainer = document.getElementById(`markets-${language}`);
    if (!marketsContainer) return;
    
    const selectedMarkets = Array.from(marketsContainer.querySelectorAll('input[type="checkbox"]:checked'))
      .map(cb => cb.value);
    
    // Update state
    if (videoTranslationState.translationResults[language]) {
      videoTranslationState.translationResults[language].markets = selectedMarkets;
      console.log(`Updated markets for ${language}:`, selectedMarkets);
    }
  };

  window.regenerateVideoTranslation = async function(language) {
    const resultCard = document.getElementById(`translation-result-${language}`);
    const regenerateBtn = resultCard?.querySelector('.translation-regenerate-btn');
    const emailInput = document.getElementById('video-translation-email');
    
    if (!regenerateBtn || !videoTranslationState.selectedVideoUrl) {
      alert('Please ensure a video is selected first.');
      return;
    }

    regenerateBtn.disabled = true;
    regenerateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Deleting old video...';

    try {
      // STEP 1: Delete the old translated video first
      const videoInfo = videoTranslationState.translationResults[language];
      if (videoInfo) {
        const originalFilename = videoTranslationState.selectedVideoFilename || '';
        const baseFilename = originalFilename.replace(/\.[^/.]+$/, '');
        
        let translatedFilename = '';
        if (videoInfo.filename) {
          translatedFilename = videoInfo.filename;
        } else {
          const extension = originalFilename.split('.').pop() || 'mp4';
          translatedFilename = `${baseFilename}_${language}.${extension}`;
        }

        console.log('Deleting old translated video before regeneration:', translatedFilename);
        
        // Send delete request
        const webhookUrl = 'https://saschag.app.n8n.cloud/webhook/list-videos';
        const params = new URLSearchParams({
          action: 'delete',
          filename: translatedFilename,
          folder: 'KJGAJ',
          language: language
        });
        
        try {
          const deleteResponse = await fetch(`${webhookUrl}?${params.toString()}`, {
            method: 'GET'
          });
          
          if (deleteResponse.ok) {
            console.log('Old video deleted successfully');
            showNotification(`ðŸ—‘ï¸ Deleted old ${language} video`, 'success');
          } else {
            console.warn('Failed to delete old video, but continuing with regeneration');
          }
        } catch (deleteError) {
          console.warn('Error deleting old video:', deleteError);
          // Continue anyway even if delete fails
        }
        
        // Remove from state
        delete videoTranslationState.translationResults[language];
        
        // Wait a moment for the deletion to process
        await new Promise(resolve => setTimeout(resolve, 1000));
      }

      // STEP 2: Start new translation
      regenerateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Sending translation request...';
      
      // Show progress update
      const progressItem = document.getElementById(`translation-progress-${language}`);
      if (progressItem) {
        const statusBadge = progressItem.querySelector('.translation-status-badge');
        const progressBar = progressItem.querySelector('.translation-progress-bar-fill');
        
        statusBadge.className = 'translation-status-badge translation-status-processing';
        statusBadge.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Preparing request';
        if (progressBar) progressBar.style.width = '10%';
      }
      
      // Download video from URL first
      const videoBlob = await fetch(videoTranslationState.selectedVideoUrl).then(r => r.blob());
      
      // Create FormData for single language
      const formData = new FormData();
      formData.append('file', videoBlob, videoTranslationState.selectedVideoFilename);
      formData.append('filename', videoTranslationState.selectedVideoFilename);
      formData.append('language', language);
      formData.append('e-mail', emailInput ? emailInput.value.trim() : '');

      // Send to n8n webhook - Use VIDEO_TRANSLATION_CONFIG
      const response = await fetch(VIDEO_TRANSLATION_CONFIG.webhookUrl, {
        method: 'POST',
        body: formData
      });

      if (!response.ok) {
        throw new Error(`Failed to send regeneration request: ${response.status}`);
      }

      const result = await response.json();
      console.log('Regeneration webhook response:', result);

      // Update button and progress UI
      regenerateBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Waiting for translation...';
      
      if (progressItem) {
        const statusBadge = progressItem.querySelector('.translation-status-badge');
        const progressBar = progressItem.querySelector('.translation-progress-bar-fill');
        
        statusBadge.className = 'translation-status-badge translation-status-processing';
        statusBadge.innerHTML = '<i class="fas fa-hourglass-half"></i> Translation in progress';
        if (progressBar) progressBar.style.width = '20%';
      }

      // Start polling for the new translated file
      showNotification(`ðŸ”„ ${language} translation started. Checking for result every 30 seconds...`, 'success');
      
      const POLLING_INTERVAL = 30000; // 30 seconds (reduced API calls)
      const MAX_ATTEMPTS = 180; // 30 minutes max
      let attempts = 0;
      const originalFilename = videoTranslationState.selectedVideoFilename || '';
      const baseFilename = originalFilename.replace(/\.[^/.]+$/, '');
      
      // Track the last known video to detect when a new one appears
      const currentVideoInfo = videoTranslationState.translationResults[language];
      const currentVideoUrl = currentVideoInfo?.url || currentVideoInfo || '';
      
      const pollInterval = setInterval(async () => {
        attempts++;
        
        // Update status with attempt count
        regenerateBtn.innerHTML = `<i class="fas fa-spinner fa-spin"></i> Checking... (${attempts}/${MAX_ATTEMPTS})`;
        if (progressItem) {
          const statusBadge = progressItem.querySelector('.translation-status-badge');
          const progressBar = progressItem.querySelector('.translation-progress-bar-fill');
          
          statusBadge.innerHTML = `<i class="fas fa-search"></i> Checking for result (${attempts}/${MAX_ATTEMPTS})`;
          const progressPercent = 20 + (attempts / MAX_ATTEMPTS * 70); // 20% to 90%
          if (progressBar) progressBar.style.width = `${Math.min(progressPercent, 90)}%`;
        }
        
        try {
          // Fetch files from Canto folder KJGAJ (where translated videos are stored)
          const cantoFiles = await fetchCantoVideos('KJGAJ');
          
          // Look for the translated file
          const matchedFile = cantoFiles.find(file => {
            const filename = file.name;
            const filenameLower = filename.toLowerCase();
            const langLower = language.toLowerCase();
            
            // Pattern 1: BaseFilename_Language.ext
            if (filename.startsWith(baseFilename + '_')) {
              const afterUnderscore = filename.substring(baseFilename.length + 1);
              const langPart = afterUnderscore.split('.')[0];
              if (langPart.toLowerCase() === langLower) return true;
            }
            
            // Pattern 2: Contains both base filename and language
            const baseFilenameLower = baseFilename.toLowerCase();
            if (filenameLower.includes(baseFilenameLower) && filenameLower.includes(`_${langLower}`)) {
              return true;
            }
            
            // Pattern 3: Try with language code
            const langCode = getLangCode(language);
            if (filename.startsWith(baseFilename + '_')) {
              const afterUnderscore = filename.substring(baseFilename.length + 1);
              const langPart = afterUnderscore.split('.')[0];
              if (langPart.toLowerCase() === langCode.toLowerCase()) return true;
            }
            
            return false;
          });
          
          if (matchedFile) {
            const newVideoUrl = matchedFile.directUrlOriginal || matchedFile.directUrl || matchedFile.url || '';
            
            // Check if this is a different video (newer) than what we had
            // This helps detect when regeneration completes
            if (newVideoUrl && newVideoUrl !== currentVideoUrl) {
              console.log(`âœ… Found regenerated video for ${language}:`, matchedFile.name);
              
              // Clear polling
              clearInterval(pollInterval);
              
              // Get current markets for this language
              const marketsContainer = document.getElementById(`markets-${language}`);
              const currentMarkets = marketsContainer 
                ? Array.from(marketsContainer.querySelectorAll('input[type="checkbox"]:checked')).map(cb => cb.value)
                : (videoTranslationState.translationResults[language]?.markets || []);
              
              // Update state with new video (save URL, filename, and markets)
              videoTranslationState.translationResults[language] = {
                url: newVideoUrl,
                filename: matchedFile.name,
                markets: currentMarkets
              };
              
              // Update progress to success
              updateVideoTranslationProgress(language, 'success');
              
              // Update button to show success
              regenerateBtn.disabled = false;
              regenerateBtn.innerHTML = '<i class="fas fa-redo"></i> Regenerate';
              
              // Update the result card with new video
              const videoElement = resultCard.querySelector('.translation-result-video');
              if (videoElement) {
                videoElement.src = newVideoUrl;
                videoElement.load(); // Reload video
              }
              
              showNotification(`âœ… ${language} translation regenerated successfully!`, 'success');
            } else {
              // Same video found, keep polling
              console.log(`â³ ${language}: Same video found, waiting for new version (attempt ${attempts}/${MAX_ATTEMPTS})`);
            }
          } else {
            console.log(`â³ ${language}: Video not found yet (attempt ${attempts}/${MAX_ATTEMPTS})`);
          }
          
          // Check if max attempts reached
          if (attempts >= MAX_ATTEMPTS) {
            clearInterval(pollInterval);
            console.warn(`â±ï¸ Polling timeout for ${language} after ${attempts} attempts`);
            
            updateVideoTranslationProgress(language, 'error');
            
            regenerateBtn.disabled = false;
            regenerateBtn.innerHTML = '<i class="fas fa-redo"></i> Regenerate';
            
            showNotification(`â±ï¸ Timeout waiting for ${language} regeneration. Please check later.`, 'error');
          }
          
        } catch (pollError) {
          console.error('Polling error:', pollError);
        }
      }, POLLING_INTERVAL);

    } catch (error) {
      console.error('Error regenerating video:', error);
      alert('An error occurred during translation. Please try again.\n' + error.message);
      
      regenerateBtn.disabled = false;
      regenerateBtn.innerHTML = '<i class="fas fa-redo"></i> Regenerate';
    }
  };

  window.deleteVideoTranslation = async function(language) {
    // Confirm deletion
    if (!confirm(`Do you want to delete the translated video for ${language}?\nThis will permanently delete the translated video.`)) {
      return;
    }

    const resultCard = document.getElementById(`translation-result-${language}`);
    const deleteBtn = resultCard?.querySelector('.translation-delete-btn');
    
    if (!deleteBtn) {
      alert('Unable to find delete button.');
      return;
    }

    // Check if we have the video info
    const videoInfo = videoTranslationState.translationResults[language];
    if (!videoInfo) {
      alert('No video information found for this language.');
      return;
    }

    // Get the filename - need to construct it from the original filename and language
    const originalFilename = videoTranslationState.selectedVideoFilename || '';
    const baseFilename = originalFilename.replace(/\.[^/.]+$/, ''); // Remove extension
    
    // Construct the translated filename pattern
    // Pattern: BaseFilename_Language.mp4 (e.g., "A New Day_English.mp4")
    let translatedFilename = '';
    
    if (videoInfo.filename) {
      // If we have the filename from the file object, use it
      translatedFilename = videoInfo.filename;
    } else {
      // Otherwise, construct it from the pattern
      const extension = originalFilename.split('.').pop() || 'mp4';
      translatedFilename = `${baseFilename}_${language}.${extension}`;
    }

    console.log('Attempting to delete translated video:', translatedFilename);

    deleteBtn.disabled = true;
    deleteBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Deleting...';

    try {
      // Send webhook to delete the file - Use GET method to avoid CORS preflight
      const webhookUrl = 'https://saschag.app.n8n.cloud/webhook/list-videos';
      const params = new URLSearchParams({
        action: 'delete',
        filename: translatedFilename,
        folder: 'KJGAJ', // The folder where translated videos are stored
        language: language
      });
      
      const response = await fetch(`${webhookUrl}?${params.toString()}`, {
        method: 'GET'
      });

      if (!response.ok) {
        throw new Error(`Failed to delete video: ${response.status}`);
      }

      const result = await response.json();
      console.log('Delete webhook response:', result);

      // Remove from state
      delete videoTranslationState.translationResults[language];

      // Remove the result card from UI
      if (resultCard) {
        resultCard.style.opacity = '0';
        resultCard.style.transform = 'scale(0.9)';
        setTimeout(() => {
          resultCard.remove();
          
          // Check if there are any remaining results
          const resultsGrid = document.getElementById('video-translation-results-grid');
          if (resultsGrid && resultsGrid.children.length === 0) {
            const resultsSection = document.getElementById('video-translation-results');
            if (resultsSection) resultsSection.style.display = 'none';
          }
        }, 300);
      }

      // Also remove from progress section if exists
      const progressItem = document.getElementById(`translation-progress-${language}`);
      if (progressItem) {
        progressItem.remove();
      }

      showNotification(`âœ… Successfully deleted ${language} video`, 'success');

    } catch (error) {
      console.error('Error deleting video:', error);
      alert('An error occurred while deleting the video. Please try again.\n' + error.message);
      
      deleteBtn.disabled = false;
      deleteBtn.innerHTML = '<i class="fas fa-trash"></i> Delete';
    }
  };

  function updateVideoTranslationResult(language, videoUrl) {
    videoTranslationState.translationResults[language] = videoUrl;
    
    const resultCard = document.getElementById(`translation-result-${language}`);
    if (resultCard) {
      const video = resultCard.querySelector('.translation-result-video');
      if (video) video.src = videoUrl;
    }
    
    updateVideoTranslationProgress(language, 'success');
  }

  window.downloadVideoTranslation = function(videoUrl, language) {
    const a = document.createElement('a');
    a.href = videoUrl;
    const filename = videoTranslationState.selectedVideoFilename ? 
      `${videoTranslationState.selectedVideoFilename.split('.')[0]}_${language}.mp4` :
      `video_${language}.mp4`;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  };

  function resetVideoTranslation() {
    videoTranslationState = {
      selectedVideoUrl: null,
      selectedVideoFilename: null,
      selectedLanguages: new Set(),
      translationResults: {},
      pollingIntervals: {}
    };

    // Reset UI
    const emailInput = document.getElementById('video-translation-email');
    const progressSection = document.getElementById('video-translation-progress');
    const resultsSection = document.getElementById('video-translation-results');
    const languageCheckboxes = document.querySelectorAll('#translation-language-checkboxes input[type="checkbox"]');
    const sourceInfo = document.getElementById('video-translation-source-info');

    if (emailInput) emailInput.value = '';
    if (progressSection) progressSection.style.display = 'none';
    if (resultsSection) resultsSection.style.display = 'none';
    if (sourceInfo) sourceInfo.style.display = 'none';
    
    languageCheckboxes.forEach(cb => cb.checked = false);

    updateStartTranslationButton();
  }

  function getLangFlag(language) {
    const flags = {
      'English': 'ðŸ‡ºðŸ‡¸',
      'Japanese': 'ðŸ‡¯ðŸ‡µ',
      'Tamil': 'ðŸ‡®ðŸ‡³',
      'Chinese': 'ðŸ‡¨ðŸ‡³',
      'Korean': 'ðŸ‡°ðŸ‡·',
      'Hindi': 'ðŸ‡®ðŸ‡³',
      'Arabic': 'ðŸ‡¸ðŸ‡¦',
      'Bengali': 'ðŸ‡§ðŸ‡©',
      'Russian': 'ðŸ‡·ðŸ‡º',
      'Marathi': 'ðŸ‡®ðŸ‡³',
      'French': 'ðŸ‡«ðŸ‡·',
      'German': 'ðŸ‡©ðŸ‡ª',
      'Portuguese': 'ðŸ‡§ðŸ‡·'
    };
    return flags[language] || 'ðŸŒ';
  }

  // ==================== END VIDEO TRANSLATION FEATURE ====================
</script>
</body>
</html>